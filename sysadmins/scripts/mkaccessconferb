#!/usr/bin/perl -w

use MIME::Base64;
use strict;

my $ldapserver="ldap.gnmedia.net";
#my $ldapserver="app1v-ldap.tp.dev.lax.gnmedia.net";
my $date=localtime();
#print '<%fqdn="app1v-xcat.dev.lax3.gnmedia.net"%>';  #<-- testing for erb
print <<"__EOF__";
#
# This file is generated by mkaccessconferb into
# puppet's top-level templates directory (where my.conf's live).
# You should probably not edit it.

# Sysadmins and root can always log in
+:root sysadmins:ALL
+:ALL:cron crond

__EOF__


## New LDAP - based group permissions generated here.

my @rawgrouplist=();
my @grouplist=();
my @lockedusers=();

#  Get list of all groups used to provide host access. 
open(LDAP,'ldapsearch -x -b "ou=Groups,dc=gnmedia,dc=net" -h '.$ldapserver.' "(&(objectClass=groupOfUniqueNames)(gnHostAccessPattern=*))" cn|') or die;

while (<LDAP>) {

   if (/^([^:]*): ?(.*)$/) {
      my ($attr,$value)=($1,$2);
      if ($value =~ s/^://) {
         $value=decode_base64($value);
      }
      if (/^cn:/) {
         push (@rawgrouplist, $value);
         next;
      } 
   }

}


chomp(@rawgrouplist);

##  create a list with the tp host access perms at the top.
##

my @tpgroups = sort (grep (/confmgmt|dba|noc|sysadmins/, @rawgrouplist));
my @devgroups = sort (grep (!/confmgmt|dba|noc|sysadmins/, @rawgrouplist));

push (@grouplist, @tpgroups);
push (@grouplist, @devgroups);


## Get list of locked users
open(LDAP,'ldapsearch -x -b "ou=People,dc=gnmedia,dc=net" -h '.$ldapserver.' "(&(objectClass=inetorgperson)(nsAccountLock=*TRUE*))" uid|') or die;

while (<LDAP>) {

   if (/^([^:]*): ?(.*)$/) {
      my ($attr,$value)=($1,$2);
      if ($value =~ s/^://) {
         $value=decode_base64($value);
      }
      if (/^uid:/) {
         push (@lockedusers, $value);
         next;
      }
   }

}


# Make a hash of the list of locked users for faster searches and matches
my %lockedhash;
@lockedhash{@lockedusers}=();


# Iterate through the list of groups, and retrieve their membership and access patterns
foreach my $group (@grouplist) {

   $group =~ s/^cn: //g;

   my @groupmembers = ();
   my @hostpatterns = ();

   open(LDAP,'ldapsearch -x -LLL -b "ou=Groups,dc=gnmedia,dc=net" -h '.$ldapserver.' "(&(objectClass=groupOfUniqueNames)(cn='.$group.'))" gnHostAccessPattern memberUid | perl -p00e "s/\r?\n //g" | ') or die;

   while (<LDAP>) {

      if (/^([^:]*): ?(.*)$/) {
         my ($attr,$value)=($1,$2);
         if ($value =~ s/^://) {
         $value=decode_base64($value);
         }		
         if (/^memberUid:/) {
            # Put username in a list as long as they are not found in list of locked users.
            push (@groupmembers, $value) unless exists $lockedhash{$value};
            next;
         }
         if (/^gnHostAccessPattern:/) {
            push(@hostpatterns, $value);
            next;
         }
      }

   }

   if ($group =~ /sysadmins|dba|confmgmt|noc/) {

      print ("\n# Host access granted based on members of the '$group' ldap group.\n");

      print map { "+:$_:ALL\n" } @groupmembers;

   }

   else {

      foreach my $pattern (@hostpatterns) {

         print "\n<% if fqdn =~ /$pattern/ %>\n";
         print "\n# Host access granted based on members of ldap group ",$group,".\n";
         print "\n# Host pattern matched: $pattern\n";

         print map { "+:$_:ALL\n" } @groupmembers;
         print "<% end %>\n";

      }

   }


}


## End new LDAP - based group permissions


## Original user-host attribute based permissions, to remain for more granular permission assignments.
my %userhosts=(); # host => [user, ...]

my $uid="";
open(LDAP,'ldapsearch -x -b "ou=People,dc=gnmedia,dc=net" -h '.$ldapserver.' "(&(uid=*)(!(nsAccountLock=*TRUE*)))" uid host|') or die;
while ($_=<LDAP>) {
   chomp;
   if (/^([^:]*): ?(.*)$/) {
      my ($attr,$value)=($1,$2);
      if ($value =~ s/^://) {
         $value=decode_base64($value);
      }
      if (/^uid:/) {
         $uid=$value;
         next;
      }
      if (/^host: XXX/) {
         next;
      }
      if (/^host:/) {
         push(@{ $userhosts{$value} }, $uid);
         next;
      }
   }
}


print "\# users with 'host: *'\n";
print map { "+:$_:ALL\n" } @{ $userhosts{'*'} };
delete $userhosts{'*'};

foreach my $host (sort keys %userhosts) {
   if ($host =~ /\*/) {
      (my $hostre=$host)=~s/\*/\.\*/g;
      print "<% if fqdn =~ /$hostre/ %>\n";
   } else {
      print "<% if fqdn == \"$host\" %>\n";
   }
   print "# users with 'host: $host'\n";
   print map { "+:$_:ALL\n" } @{ $userhosts{$host} };
   print "<% end %>\n";
}


print <<__EOF__;

# Default deny all at the end
-:ALL:ALL
__EOF__

