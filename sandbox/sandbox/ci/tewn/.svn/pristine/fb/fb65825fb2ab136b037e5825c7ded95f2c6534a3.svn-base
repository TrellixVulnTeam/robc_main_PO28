<?php

namespace CI\Validator;

class Referer extends Rule
{
    const INVALID     = 'refererInvalid';
    const NOT_ALLOWED = 'notAllowedRefer';

    const TYPE_ALLOWED    = 'allowed';
    const TYPE_DISALLOWED = 'disallowed';
    const TYPE_BOTH       = '';

    /**
     * @var array
     */
    protected $aMessageTemplates = array(
        self::NOT_ALLOWED => "Not allowed referer detected: [%value%]",
        self::INVALID     => "Invalid referer",
    );

    /**
     * @var array
     */
    protected $aAllowedDomains = array();

    /**
     * @var array
     */
    protected $aDisallowedDomains = array();

    /**
     * Set the allowed domains.
     *
     * Any allowed domain that already exists in our disallow list, is cleared
     * from the disallow list and make it valid again.
     *
     * @param array $aDomains The domains
     *
     * @return CI/Validator/Referer
     */
    public function setAllowedDomains(array $aDomains)
    {
        $this->aAllowedDomains    = $aDomains;
        $this->aDisallowedDomains = array_diff($this->aDisallowedDomains, $aDomains);
        return $this;
    }

    /**
     * Returns allowed domains for this validator.
     *
     * @return array
     */
    public function getAllowedDomains()
    {
        return $this->aAllowedDomains;
    }

    /**
     * Allow the domain only if a string is given.
     *
     * @param string $sDomain The domain
     *
     * @return CI/Validator/Referer
     */
    public function allowDomain($sDomain)
    {
        $sDomain = (string) $sDomain;
        if (in_array($sDomain, $this->aDisallowedDomains)) {
            foreach ($this->aDisallowedDomains as $nKey => $sValue) {
                if ($sValue == $sDomain) {
                    unset($this->aDisallowedDomains[$nKey]);
                    $this->aDisallowedDomains = array_values($this->aDisallowedDomains);
                }
            }
        }
        $this->aAllowedDomains[] = $sDomain;
        return $this;
    }

    /**
     * Mark the given domains as not valid domains.
     *
     * @param array $aDomains The domains
     *
     * @return CI/Validator/Referer
     */
    public function setDisAllowedDomains(array $aDomains)
    {
        $this->aDisallowedDomains = $aDomains;
        $this->aAllowedDomains    = array_diff($this->aAllowedDomains, $aDomains);
        return $this;
    }

    /**
     * Return the disallowed domains.
     *
     * @return array
     */
    public function getDisAllowedDomains()
    {
        return $this->aDisallowedDomains;
    }

    /**
     * Disallow a domain only if a string is give.
     *
     * @param string $sDomain The domain
     *
     * @return CI/Validator/Referer
     */
    public function disallowDomain($sDomain)
    {
        $sDomain = (string) $sDomain;
        if (in_array($sDomain, $this->aAllowedDomains)) {
            foreach ($this->aAllowedDomains as $nKey => $sValue) {
                if ($sValue == $sDomain) {
                    unset($this->aAllowedDomains[$nKey]);
                    $this->aAllowedDomains = array_values($this->aAllowedDomains);
                }
            }
        }
        $this->aDisallowedDomains[] = $sDomain;
        return $this;
    }

    /**
     * Reset the list of allowed domains.
     *
     * @return CI/Validator/Referer
     */
    public function resetAllowedDomains()
    {
        $this->reset('allowed');
        return $this;
    }

    /**
     * Reset the list of disallowed domains.
     *
     * @return CI/Validator/Referer
     */
    public function resetDisAllowedDomains()
    {
        $this->reset('disallowed');
        return $this;
    }

    /**
     * Reset the especified list with the parameter $sType.
     *
     * Valid types are: allowed & disallowed.
     *
     * Any not valid type will reset both lists.
     *
     * @param string $sType The type
     *
     * @return CI/Validator/Referer
     */
    public function reset($sType = self::TYPE_BOTH)
    {
        switch(strtolower($sType)) {
            case self::TYPE_ALLOWED:
                $this->aAllowedDomains = array();
                break;
            case self::TYPE_DISALLOWED:
                $this->aDisallowedDomains = array();
                break;
            default:
                $this->aAllowedDomains = array();
                $this->aDisallowedDomains = array();
                break;
        }
        return $this;
    }

    /**
     * Returns true if and only if $mValue meets the validation requirements,
     * if an empty $mValue is passed, this method return true.
     *
     * If $mValue fails validation, then this method returns false and getMessages()
     * will return an array of messages that explain why the validation failed.
     *
     * @param mixed $mValue The value to validate
     *
     * @return boolean
     */
    public function isValid($mValue)
    {
        $this->setValue($mValue);

        // If value is empty no validation are made
        if (empty($mValue)) {
            return true;
        }

        // If no ACL list are set, no validation are made
        if (empty($this->aAllowedDomains) && empty($this->aDisallowedDomains)) {
            return true;
        }

        // If no allowed ACL is set, disallow only the domains in disallowed ACL
        if (empty($this->aAllowedDomains)
            && $this->containsDomain($this->aDisallowedDomains, $mValue)
        ) {
            $this->error(self::NOT_ALLOWED);
            return false;
        }

        // If no disallowed ACL is set, allow only the domains in allowed ACL
        if (empty($this->aDisallowedDomains)
            && !$this->containsDomain($this->aAllowedDomains, $mValue)
        ) {
            $this->error(self::NOT_ALLOWED);
            return false;
        }

        // For everything else just ACL allow list
        if (!empty($this->aAllowedDomains) && !empty($this->aDisallowedDomains)) {
            if (!$this->containsDomain($this->aAllowedDomains, $mValue)) {
                $this->error(self::NOT_ALLOWED);
                return false;
            }
        }

        // Don't reach this point
        return true;
    }

    /**
     * Verify if the given value begin with one of the domains of the given list.
     *
     * @param array  $aList  The list
     * @param string $sValue The domain
     *
     * @return boolean
     */
    protected function containsDomain(array $aList, $sValue)
    {
        foreach ($aList as $sDomain) {
            if (preg_match("/^(?:http(?:s)?:\/\/)?$sDomain/", $sValue, $aMatches)) {
                return true;
            }
        }
        return false;
    }
}