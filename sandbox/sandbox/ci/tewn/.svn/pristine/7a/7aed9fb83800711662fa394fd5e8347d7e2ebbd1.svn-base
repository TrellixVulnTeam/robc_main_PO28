<?

/*
 * Stats Component
 */
class StatisticComponent extends Object {

	function zscore($population_average, $population_stddev, $individual) {
		$diff = $individual - $population_average;
		return $diff / $population_stddev;
	}

	function average($a) {
		//variable and initializations
		$array_sum = array_sum($a); //sum the num of elements
		$number_elements = count($a); //count the num of elements

		if (!$number_elements) {
			return 0;
		}

		return $array_sum / $number_elements;
	}

	function standard_deviation_sample($a) {
		$count = count($a);
		if (!$count) {
			return 0;
		}

		return $this->standard_deviation_sample_count($count);
	}

	function standard_deviation_sample_count($count) {
		return (1 / pow($count, 0.5));
	}

	function standard_deviation_population($a) {
		//		return stats_standard_deviation($a);

		//variable and initializations
		$standard_deviation = 0.0;
		$variance = 0.0;
		$mean = 0.0;
		$array_sum = array_sum($a); //sum the num of elements
		$number_elements = count($a); //count the num of elements

		if (!$number_elements) {
			return 0;
		}

		//calculate the mean
		$mean = $array_sum / $number_elements;
		
		//calculate the variance
		foreach ($a as $element) {
			//sum the array
			$variance += pow(($element - $mean), 2);
		}
		
		$variance = $variance / $number_elements;
		
		//calculate the standard deviation
		$standard_deviation = pow($variance, 0.5);
		
		//return the variance
		return $standard_deviation;
	}

	function margin_error($a) {
		$count = count($a);
		if (!$count) {
			return 0;
		}
		$stddev = $this->standard_deviation_population($a);

		return $stddev * $this->standard_deviation_sample_count($count);
	}

	function margin_error_proportion($avg, $num) {
		if ($avg == 1 && $num == 1) {
			return 1;
		}

		if ($avg > 1) {
			return 1;
		}

		if (!$num) {
			return 0;
		}
		$tmp = $avg * (1 - $avg) / $num;

		plat_assert(!is_nan($tmp));

		return pow($tmp, 0.5);
	}

	function erf($x) { 
        $pi = 3.1415927; 
        $a = (8*($pi - 3))/(3*$pi*($pi - 4)); 
        $x2 = $x * $x; 

        $ax2 = $a * $x2; 
        $num = (4/$pi) + $ax2; 
        $denom = 1 + $ax2; 

        $inner = (-$x2)*$num/$denom; 
        $erf2 = 1 - exp($inner); 

        return sqrt($erf2); 
	} 

	function cdf($n) { 
        if ($n < 0) { 
			return (1 - $this->erf($n / sqrt(2)))/2; 
        } else { 
			return (1 + $this->erf($n / sqrt(2)))/2; 
        } 
	}

	// Very sparse percentile to zscore table
	function confidence_to_zscore($confidence) {
		switch ($confidence) {
		case 0.5657:			// Adjusted for overlap on 68%
			return 0.7819;
		case 0.68:
			return 1;
		case 0.6838:			// Adusted for overlap on 90%
			return 1.0023;
		case 0.90:
			return 1.64;
		case 0.7764:			// Adjusted for overlap on 95%
			return 1.217;
		case 0.95:
			return 1.96;
		case 0.99:
			return 2.58;
		default:
			echo "Don't know about confidence: ".$confidence."<br>";
			plat_assert(0, array('confidence' => $confidence, 'msg' => 'Don\'t know about confidence'), false); // not exit in this assert
		}
	}

	// Says w/ $confidence % if $a is better than $b
	function is_best_sample($a, $b, $confidence = 0.95) {
		$a_me = $this->margin_error($a);
		$b_me = $this->margin_error($b);

		$a_avg = $this->average($a);
		$b_avg = $this->average($b);

		// Adjust confidence for overlap probabilities
		// Need to figure out probability of _not_ overlapping
		$adjusted_confidence = 1 - pow((1 - $confidence), .5);
		$adjusted_confidence = round($adjusted_confidence, 4);

		$zscore = $this->confidence_to_zscore($adjusted_confidence);

		$a_bottom = $a_avg - ($a_me * $zscore);
		$b_top = $b_avg + ($b_me * $zscore);

		if ($a_bottom > $b_top) {
			return 1;
		} else {
			return 0;
		}
	}

	// Says w/ $confidence % if $a is better than $b
	function is_best_proportion($a_avg, $b_avg, $a_num, $b_num, $confidence = 0.95) {
		$a_me = $this->margin_error_proportion($a_avg, $a_num);
		$b_me = $this->margin_error_proportion($b_avg, $b_num);

		// Adjust confidence for overlap probabilities
		// Need to figure out probability of _not_ overlapping
		$adjusted_confidence = 1 - pow((1 - $confidence), .5);
		$adjusted_confidence = round($adjusted_confidence, 4);

		$zscore = $this->confidence_to_zscore($adjusted_confidence);

		$a_bottom = $a_avg - ($a_me * $zscore);
		$b_top = $b_avg + ($b_me * $zscore);

		if ($a_bottom > $b_top) {
			return 1;
		} else {
			return 0;
		}
	}

}
?>
