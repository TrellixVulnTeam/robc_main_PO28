<?php

namespace CI\Stats\Account;

class Delta extends Adapter
{
    /**
     * @param  mixed $mAccountId The account id as numeric or an array with a list
     *                           of account id
     * @param  boolean $bGroupBy True when we want to group by account id or false otherwise
     */
    public function getStats($mAccountId, $sStartDate, $sEndDate, $bGroupBy = false)
    {
        $sStartDate = date('Y-m-d H:i:s', strtotime($sStartDate));
        $sEndDate   = date('Y-m-d H:i:s', strtotime($sEndDate));

        $nStartDate = strtotime($sStartDate);
        $nEndDate   = strtotime($sEndDate);
        $sCondition = "msa.account_id";
        $sGroupBy   = $bGroupBy ? 'GROUP BY msa.account_id' : "";

        if (is_array($mAccountId)) {
            $sCondition .= ' IN (' . implode(",", $mAccountId) . ')';
        } else {
            $sCondition .= ' =' . intval($mAccountId);
        }

        $sQuery = $bGroupBy ? "SELECT msa.account_id," : "SELECT";
        $sQuery .= "
            IFNULL(SUM(msa.incoming), 0) AS incoming,
            IFNULL(SUM(msa.outgoing),0) AS outgoing,
            IFNULL(SUM(msa.credits),0) AS credits,
            IFNULL((
                SELECT sa1.initial_credits
                FROM stats_accounts sa1
                WHERE
                    sa1.account_id = msa.account_id
                    AND sa1.created = (
                        IF((MAX(msa.created) + 3600) > UNIX_TIMESTAMP(CURRENT_TIMESTAMP), MAX(msa.created),
                            (MAX(msa.created) + 3600))
                    )
                ),
            0) AS initial_credits
        FROM stats_accounts AS msa
        WHERE " . $sCondition . "
            AND msa.created BETWEEN {$nStartDate} AND {$nEndDate} " . $sGroupBy;

        $aStats = $this->oModel->query_read($sQuery, false);

        if ($bGroupBy) {
            $aStats = $this->buildByGroupId($aStats, $mAccountId);
        } else {
            $aStats = $this->buildById($aStats);
        }

        return $aStats;
    }

    protected function buildById($mResultSet)
    {
        if (is_array($mResultSet)) {
            // 2 array_shift because of the cake model behaviour
            $mResultSet = array_shift($mResultSet);
            $mResultSet = array_shift($mResultSet);
        } else {
            $mResultSet = $this->getEmptyStats();
        }

        if (!isset($mResultSet['initial_credits'])) {
            $mResultSet['initial_credits'] = 0;
        }

        return array(
            'incoming' => (int) $mResultSet['incoming'],
            'outgoing' => (int) $mResultSet['outgoing'],
            'credits'  => (int) $mResultSet['initial_credits'],
        );
    }

    protected function buildByGroupId($mResultSet, array $aAccounts)
    {
        $aReturn   = array();
        $aAccounts = array_flip($aAccounts);

        if (is_array($mResultSet)) {
            foreach ($mResultSet as $aStat) {
                $nAccountId = (int)$aStat['msa']['account_id'];
                $aReturn[$nAccountId]['account_id'] = $nAccountId;
                $aReturn[$nAccountId]['incoming']   = (int) $aStat[0]['incoming'];
                $aReturn[$nAccountId]['outgoing']   = (int) $aStat[0]['outgoing'];
                $aReturn[$nAccountId]['credits']    = isset($aStat[0]['initial_credits'])?
                                                        (int) $aStat[0]['initial_credits'] : 0;

                unset($aAccounts[$nAccountId]);
            }
        }

        // Fill with zeros accounts that doesn't have data
        if (false === empty($aAccounts)) {
            $aEmptyStats = array_fill_keys(array_keys($aAccounts), $this->getEmptyStats());
            $aReturn = $aReturn + $aEmptyStats;
        }

        return $aReturn;

    }
}