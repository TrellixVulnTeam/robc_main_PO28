<?php

/**
 * Lecture and processing of the logs of widget clicks
 *
 * PHP Version 5.3
 *
 * @category CI
 * @package  CI\VowpalWabbit\Parser\Widget
 * @author   Julio Rodriguez <julio.rodriguez@evolvemediallc.com>
 * @license  Evolve Media LLC
 * @link     http://crowdignite.com
 */

namespace CI\VowpalWabbit\Parser\Widget;
use CI\VowpalWabbit\Parser\Common;
use CI\File\Exception;

/**
 * Lecture and processing of the logs of widget clicks
 *
 * PHP Version 5.3
 *
 * @category CI
 * @package  CI\VowpalWabbit\Parser\Widget
 * @author   Julio Rodriguez <julio.rodriguez@evolvemediallc.com>
 * @license  Evolve Media LLC
 * @link     http://crowdignite.com
 */

class Clicks extends Common
{
    const TIME_RANGE = 3600;
    protected $sPrefixName = 'wclick.log.';
    protected $sServerPattern = "/^app[\d].*ci./";
    protected $aKeys = array(
        'unix_timestamp',
        'user_id',
        'link_click_page_id',
        'link_click_slot'
    );

    /**
     * Constructor of the class
     *
     * @param string $sDate date we will be process
     *
     * @return  WidgetImpressions object.
     */
    public function __construct($sDate)
    {
        $this->sDate = $sDate;
        $this->sDateFile = $this->increment30Minutes($sDate);
        parent::__construct();
    }

    /**
     * Reading the log
     *
     * @param integer $nLimit number of lines
     *
     * @return array[StdObject] with all the properties of one WidgetImpressions
     * @throws CI\File\Exception when the file can't be read
     */
    public function readLog($nLimit = null)
    {
        $aReturn = array();
        $sPhysicalFiles = $this->getNecessaryLogs();
        $nTotal = 0;

        foreach ($sPhysicalFiles as $sFilePath) {

            if (null !== $nLimit && $nTotal >= $nLimit) {
                break;
            }

            $oHandle = @fopen($sFilePath, "r");

            if (false !== $oHandle) {
                $oLine = null;

                while (!feof($oHandle)) {
                    $sLine = fgets($oHandle);

                    if (!empty($sLine)) {
                        $aLine = explode(',', $sLine);
                        $aLine = $this->cutData($aLine);

                        foreach ($aLine as $key => $value) {
                            $value = $this->sanitaze($value);
                            $aLine[$key] =$value;
                        }

                        $oLine = (object) array_combine($this->aKeys, $aLine);

                        if (!$this->isInTimeFrame($oLine->unix_timestamp, self::TIME_RANGE)) {
                            continue;
                        }

                        $sKey = $oLine->user_id . '-' . $oLine->link_click_page_id;
                        $aReturn[$sKey] = $oLine;
                        $nTotal++;

                        if (null !== $nLimit && $nTotal >= $nLimit) {
                            break;
                        }
                    }
                }
                fclose($oHandle);
            }
        }

        if (empty($aReturn)) {
            $print = print_r($sPhysicalFiles, true);
            throw new Exception(
                Exception::FILE_NOT_FOUND, $print
            );
        }

        return $aReturn;
    }

    protected function getNecessaryLogs()
    {
        $next30MinutesLog = $this->increment30Minutes($this->sDateFile);
        $aFiles = $this->getAllLogs($this->sDateFile);
        $aFiles = array_merge($aFiles, $this->getAllLogs($next30MinutesLog));
        return $aFiles;
    }

    public function cleanUp()
    {
        $this->moveDoneFiles($this->sDateFile);
    }

    /**
     * Data to be cut respect of the size of $this->aKeys
     *
     * @param array $aData to be cut
     *
     * @return array
     */
    protected function cutData(array $aData)
    {
        $nTotalItems = count($this->aKeys);
        $aData = array_slice($aData, 0, $nTotalItems);
        return $aData;
    }
}