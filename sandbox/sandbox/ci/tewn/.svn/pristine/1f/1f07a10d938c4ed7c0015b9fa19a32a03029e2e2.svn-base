<?php
/**
 * Image Manipulator File
 *
 * PHP Version 5.3
 *
 * @author   Francisco Gonzalez <francisco.gonzalez@evolvemediallc.com>
 * @license  Evolve Media LLC
 * @link     http://www.crowdignite.com
 */

namespace CI\Image;

/**
 * Image Manipulator Class
 *
 * PHP Version 5.3
 *
 * @author   Francisco Gonzalez <francisco.gonzalez@evolvemediallc.com>
 * @license  Evolve Media LLC
 * @link     http://www.crowdignite.com
 */
class Manipulator
{
    const UPLOAD_PATH_INDEX     = 'upload';
    const CACHE_PATH_INDEX      = 'cache';
    const UPLOAD_TMP_PATH_INDEX = 'upload_tmp';
    const IMAGES_PATH_INDEX     = 'images';

    protected $aPaths      = array();
    protected $oFilter     = null;
    protected $aMinSizes   = array();
    protected $aValidators = array();
    protected $oImageDriver;

    public function __construct()
    {
        $this->aPaths = array(
            self::IMAGES_PATH_INDEX     => ROOT.DS.APP_DIR.DS.WEBROOT_DIR.DS.IMAGES_URL,
            self::UPLOAD_PATH_INDEX     => ROOT.DS.APP_DIR.DS.WEBROOT_DIR.DS.IMAGES_URL.'upload/',
            self::UPLOAD_TMP_PATH_INDEX => ROOT.DS.APP_DIR.DS.WEBROOT_DIR.DS.IMAGES_URL.'upload/tmp/',
            self::CACHE_PATH_INDEX      => ROOT.DS.APP_DIR.DS.WEBROOT_DIR.DS.IMAGES_URL.'upload/cache/',
        );

        $this->oFilter = new \CI\Filter\String\Slug();
    }

    private function _setPath($sIndex, $sValue)
    {
        if (!is_string($sValue)) {
            throw new Exception(Exception::INVALID_PATH_TYPE, gettype($sValue));
        }

        $this->aPaths[$sIndex] = $sValue;
    }

    public function setMininalSizes($nWidth, $nHeight)
    {
        if (!is_numeric($nWidth)) {
            throw new Exception(Exception::INVALID_TYPE, 'Width should be numerics and is ' . gettype($nWidth));
        }

        if (!is_numeric($nHeight)) {
            throw new Exception(Exception::INVALID_TYPE, 'Height should be numerics and is ' . gettype($nHeight));
        }

        $this->aMinSizes = array(
            'width'  => (int)$nWidth,
            'height' => (int)$nHeight
        );

        return $this;
    }

    public function setUploadPath($sPath)
    {
        $this->_setPath(self::UPLOAD_PATH_INDEX, $sPath);
        return $this;
    }

    public function setUploadTmpPath($sPath)
    {
        $this->_setPath(self::UPLOAD_TMP_PATH_INDEX, $sPath);
        return $this;
    }

    public function setImagesPath($sPath)
    {
        $this->_setPath(self::IMAGES_PATH_INDEX, $sPath);
        return $this;
    }

    public function setCachePath($sPath)
    {
        $this->_setPath(self::CACHE_PATH_INDEX, $sPath);
        return $this;
    }

    public function getCacheImagesPath()
    {
        return $this->aPaths[self::CACHE_PATH_INDEX];
    }

    public function getUploadPath()
    {
        return $this->aPaths[self::UPLOAD_PATH_INDEX];
    }

    public function getUploadTmpPath()
    {
        return $this->aPaths[self::UPLOAD_TMP_PATH_INDEX];
    }

    public function getImagesPath()
    {
        return $this->aPaths[self::IMAGES_PATH_INDEX];
    }

    public function import($sUrl, $bOverwrite = false)
    {
        $this->validatePath(self::UPLOAD_PATH_INDEX);

        $oFileSystem = $this->getFileSystemObject();
        $oFile       = $oFileSystem->readRemote($sUrl);
        $oImage      = $this->getFileImageObject($oFile);

        $sFilePath   = sprintf(
            '%s%s_%s.%s',
            $this->aPaths[self::UPLOAD_PATH_INDEX],
            $this->oFilter->filter($oImage->getName()),
            uniqid(),
            $oImage->getExtension()
        );
        $sFilePath  = $this->getNewPath($sFilePath);
        $this->existPath($sFilePath, true);

        if (!$this->validateSize($oImage->getSize())) {
            $sErrors = implode(', ', $this->aValidators['size']->getMessages());
            throw new Exception(Exception::ERROR_VALIDATOR, $sErrors);
        }

        if (!$oFileSystem->write($oImage, $sFilePath, $bOverwrite)) {
            throw new Exception(Exception::ERROR_WRITING_FILE, $sFilePath);
        }

        $oImage = $this->getFileImageObject($oFileSystem->read($sFilePath));
        $sReturnPath = 'upload/' . $oFileSystem->getBaseNameNestedDir($sFilePath, 3);

        return $sReturnPath;
    }

    public function importFromStream($bOverwrite = false)
    {
        $this->validatePath(self::UPLOAD_PATH_INDEX);
        $oFileSystem = $this->getFileSystemObject();
        $oFile       = $oFileSystem->readRemoteFromStream();
        $oImage      = $this->getFileImageObject($oFile);

        $sFilePath   = sprintf(
            '%s%s_%s.%s',
            $this->aPaths[self::UPLOAD_PATH_INDEX],
            $this->oFilter->filter($oImage->getName()),
            uniqid(),
            $oImage->getExtension()
        );
        $sFilePath  = $this->getNewPath($sFilePath);
        $this->existPath($sFilePath, true);

        if (!$this->validateSize($oImage->getSize())) {
            $sErrors = implode(', ', $this->aValidators['size']->getMessages());
            throw new Exception(Exception::ERROR_VALIDATOR, $sErrors);
        }

        if (!$oFileSystem->write($oImage, $sFilePath, $bOverwrite)) {
            throw new Exception(Exception::ERROR_WRITING_FILE, $sFilePath);
        }

        $oImage = $this->getFileImageObject($oFileSystem->read($sFilePath));
        $sReturnPath = 'upload/' . $oFileSystem->getBaseNameNestedDir($sFilePath, 3);

        return $sReturnPath;
    }

    public function isNewPath($sImagePath)
    {
        $sImageLikeDBRow = substr($sImagePath, strpos($sImagePath, 'upload/'));
        $aDirectories = explode('/', $sImageLikeDBRow);

        return isset($aDirectories[4]);
    }

    public function getNewPath($sFileName)
    {
        $oFileSystem = $this->getFileSystemObject();
        $aPathInfo   = new \CI\ArrayManipulator(pathinfo($sFileName));
        $aFileName   = str_split($aPathInfo->get('filename'));
        $nSize       = count($aFileName)-1;

        return $aPathInfo->get('dirname', '') . '/' .
            $aFileName[$nSize-2] . '/' .
            $aFileName[$nSize-1] . '/'  .
            $aFileName[$nSize] . '/' .
            $aPathInfo->get('basename', '');
    }

    public function setValidatorSize(\CI\Validator\Image\Size $oSizeValidator)
    {
        $this->aValidators['size'] = $oSizeValidator;

        return $this;
    }

    protected function validateSize($aSize)
    {
        $bReturn = true;

        if (isset($this->aValidators['size'])) {
            $bReturn = $this->aValidators['size']->isValid($aSize);
        }

        return $bReturn;
    }

    protected function validatePath($sPathIndex)
    {
        if (empty($this->aPaths[$sPathIndex])) {
            throw new Exception(Exception::UNDEFINED_PATH, $sPathIndex);
        }
    }

    public function getImageDriver()
    {
        return $this->oImageDriver;
    }

    public function setImageDriver($oDriver)
    {
        $this->oImageDriver = $oDriver;
    }

    public function cropImage($sImagePath, $nX1, $nX2, $nY1, $nY2)
    {
        if (empty($sImagePath)) {
            throw new Exception(Exception::UNDEFINED_PATH, $sImagePath);
        }

        $this->validatePath(self::UPLOAD_PATH_INDEX);
        $oFileSystem = $this->getFileSystemObject();
        $oFile       = $oFileSystem->read($sImagePath);
        $oImage      = $this->getFileImageObject($oFile);
        $oImgDriver  = $this->getIMagickObject($sImagePath);
        $this->setImageDriver($oImgDriver);

        $nWidth = $nX2 - $nX1;
        $nHeight = $nY2 - $nY1;

        $bResult = $oImgDriver->cropImage($nWidth, $nHeight, $nX1, $nY1);

        if ($bResult && $this->existPath($sImagePath, true)) {
            $bResult = $oImgDriver->writeImage($sImagePath);
        }

        return $bResult;
    }

    public function cropThumbnailImage($sImagePath, $nWidth, $nHeight, $sNewPath = '')
    {
        if (empty($sImagePath)) {
            throw new Exception(Exception::UNDEFINED_PATH, $sImagePath);
        }

        $this->validatePath(self::UPLOAD_PATH_INDEX);
        $oFileSystem = $this->getFileSystemObject();
        $oFile       = $oFileSystem->read($sImagePath);
        $oImage      = $this->getFileImageObject($oFile);
        $oImgDriver  = $this->getIMagickObject($sImagePath);
        $this->setImageDriver($oImgDriver);

        $bResult = $oImgDriver->cropThumbnailImage($nWidth, $nHeight);

        if ($bResult) {
            if (empty($sNewPath)) {
                $sNewPath = $sImagePath;
            }

            if ($this->existPath($sNewPath, true)) {
                $bResult = $oImgDriver->writeImage($sNewPath);
            } else {
                error_log(
                    __METHOD__ .
                    ' Error creating the crop of ' . $sImagePath .
                    ' with the dirs ' . $sNewPath
                );
            }
        }

        return $bResult;
    }

    public function existPath($sPath, $bCreate = false)
    {
        $bReturn = false;
        $oFileSystem = $this->getFileSystemObject();
        $aPathInfo = pathinfo($sPath);

        $bReturn = $oFileSystem->exists($aPathInfo['dirname']);

        if (!$bReturn && $bCreate) {
            $bResult = $oFileSystem->createDir($aPathInfo['dirname'], 0755, true);
        }

        return $bReturn;
    }

    protected function getFileImageObject(\CI\IO\File  $oFile)
    {
        return new \CI\IO\File\Image($oFile);
    }

    protected function getFileSystemObject()
    {
        return new \CI\IO\File\System();
    }

    protected function getIMagickObject($sPath)
    {
        return new \CI\Image\Drivers\IMagick($sPath);
    }

    public function delete($sPath)
    {
        $oFileSystem = $this->getFileSystemObject();
        $oFileSystem->delete($sPath);
    }

    public function processImage($sImage, array $aCoordinates = array())
    {
        if (strpos(trim($sImage), 'http') === 0) {
            $sImage = $this->import($sImage);
        } else {
            $sImage = str_replace('/img/', '', $sImage);
        }

        if (!empty($aCoordinates)) {
            $oLocation = new \CI\ArrayManipulator($aCoordinates);

            $nX1 = (int) $oLocation->get('x1', 0);
            $nX2 = (int) $oLocation->get('x2', 0);
            $nY1 = (int) $oLocation->get('y1', 0);
            $nY2 = (int) $oLocation->get('y2', 0);

            if ($nX2 > 0 && $nY2 > 0) {
                $sImageFullPath = $this->getImagesPath() . $sImage;
                $this->cropImage(
                    $sImageFullPath,
                    $nX1,
                    $nX2,
                    $nY1,
                    $nY2
                );
            }
        }

        return $sImage;
    }
}