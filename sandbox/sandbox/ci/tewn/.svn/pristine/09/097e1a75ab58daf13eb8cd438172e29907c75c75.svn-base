<?php
/**
 * Curl class
 *
 * It will make curl connections with the same resource
 *
 */
class Curl {

	// Make this class a singleton
	static private $instance = null;
	private $curl;

	/**
	 * Builds the curl class with the general parameters
	 */
	private function __construct() {
		$options = array(
			CURLOPT_RETURNTRANSFER => true,     // return web page
			CURLOPT_HEADER         => false,    // don't return
												// headers
			CURLOPT_ENCODING       => "",       // handle compressed
			CURLOPT_USERAGENT      => "spider", // who am i
			CURLOPT_AUTOREFERER    => true,     // set referer on
												// redirect
			CURLOPT_CONNECTTIMEOUT => 120,      // timeout on connect
			CURLOPT_TIMEOUT        => 5,        // timeout on response
			CURLOPT_MAXREDIRS      => 10,       // stop after 10
												// redirects
		);
		$this->curl = curl_init();
		curl_setopt_array($this->curl, $options);
	}

	/**
	 * Close the resource when the object is destroyed
	 */
	public function __destruct() {
		curl_close( $this->curl );
	}

	/**
	 * Sets the url for this curl resource
	 *
	 * @param string $url The url to work with
	 */
	public function set_url($url) {
		curl_setopt($this->curl, CURLOPT_URL, $url);
	}

	/**
	 * Get the information and headers from the curl resource
	 *
	 * @param  string $url The url to get headers from
	 *
	 * @return array Of errno, errmsg and content for the url
	 */
	public function get_headers($url = null) {
		if ($url !== null && is_string($url)) {
			$this->set_url($url);
		}
		$content = $this->curl_redir_exec( $this->curl );
		$err     = curl_errno( $this->curl );
		$errmsg  = curl_error( $this->curl );
		$header  = curl_getinfo( $this->curl );

		$header['errno']   = $err;
		$header['errmsg']  = $errmsg;
		$header['content'] = $content;

		return $header;
	}

	/**
	 * Get the curl instance for this singleton
	 *
	 * @return Curl object instance of this class
	 */
	static public function instance() {
		if (self::$instance == null) {
			self::$instance = new Curl();
		}
		return self::$instance;
	}

	/**
	 * Intended to do the same as curl_exec recursively when a redirect header exist.
	 * Based on the comment http://au.php.net/manual/ro/function.curl-setopt.php#71313
	 *
	 * @param object $ch a curl resource
	 *
	 * @return string The content from that curl resource
	 */
	private function curl_redir_exec($ch)
	{
		static $curl_loops = 0;
		static $curl_max_loops = 20;
		if ($curl_loops++ >= $curl_max_loops)
		{
			$curl_loops = 0;
			return FALSE;
		}
		curl_setopt($ch, CURLOPT_HEADER, true);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		$data = curl_exec($ch);

		$separator = strpos($data, "\r\n\r\n");
		$header = substr($data, 0, $separator);
		$data = substr($data, $separator + 4);

		 $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);

		if ($http_code == 301 || $http_code == 302)
		{
			$matches = array();
			preg_match('/Location:(.*?)\n/i', $header, $matches);
			$url = @parse_url(trim(array_pop($matches)));
			if (!$url)
			{
				//couldn't process the url to redirect to
				$curl_loops = 0;
				return $data;
			}
			$last_url = parse_url(curl_getinfo($ch, CURLINFO_EFFECTIVE_URL));
			if (!isset($url['schme']) || !$url['scheme']) {
				$url['scheme'] = $last_url['scheme'];
			}
			if (!isset($url['host']) || !$url['host']) {
				$url['host'] = $last_url['host'];
			}
			if (!isset($url['path']) || !$url['path']) {
				$url['path'] = $last_url['path'];
			}
			$new_url = $url['scheme'] . '://' . $url['host'] . $url['path'] . (isset($url['query'])?'?'.$url['query']:'');
			curl_setopt($ch, CURLOPT_URL, $new_url);
			return $this->curl_redir_exec($ch);
		} else {
			$curl_loops=0;
			return $data;
		}
	}
}
