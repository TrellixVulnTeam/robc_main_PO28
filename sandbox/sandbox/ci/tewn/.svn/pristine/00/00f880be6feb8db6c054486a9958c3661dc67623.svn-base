<?php
/**
 * Wrapper for Memcached, v. 0.6
 *
 * Uses both memcache & memcached PHP modules
 *
 * Modified by: Jake Moilanen (http://jakem.net)
 * Modified by: Chris Thompson (http://www.thompsonbd.com)
 * Author: Jiri Kupiainen (http://jirikupiainen.com/)
 *
 * You are free to do whatever you please with this code. Enjoy.
 */
global $memcached_connection;

define("MEMCACHE_CLIENT", 0);

class CakeMemcacheComponent {
	var $_connected = false;
	var $_Memcached = null;
	var $servers = array();
	var $debug = 1;

	function startup(&$controller) {

	}

	/**
	 * Connect to the memcached server(s)
	 */
	function CakeMemcacheComponent($session_servers = 0) {
		global $memcached_connection;

		if (defined('DISABLE_CACHE')) {
			return false;
		}

		if ($memcached_connection) {
			$this->_Memcached = $memcached_connection;
			$this->_connected = true;
			return true;
		}

		if (MEMCACHE_CLIENT) {
			$this->_Memcached = new Memcache();
		} else {
			$this->_Memcached = new Memcached();
      $this->_Memcached->setOption(Memcached::OPT_DISTRIBUTION, Memcached::DISTRIBUTION_CONSISTENT);
		}

		$this->servers = Configure::read('memcache_servers');

		if ($session_servers) {
			$this->servers = Configure::read('memcache_sessions');
		}

		// several servers - use addServer
    if (MEMCACHE_CLIENT) {
		  foreach ($this->servers as $server) {
			  $host = $server[0];
			  $port = ((isset($server[1])) ? $server[1] : 11211); // default port

        if ($this->_Memcached->addServer($host, $port)) {
				  $this->_connected = true;
			  } else {
				  $this->_connected = false;
			  }
		  }
    } else {
      if ($this->_Memcached->addServers($this->servers)) {
        $this->_connected = true;
      } else {
        $this->_connected = false;
      }
    }

		if ($this->_connected) {
			$memcached_connection = $this->_Memcached;;
		}

		return $this->_connected;
	}

	function __destruct() {

	}

	// Old API
	function memcache_connect() {
		if (defined('DISABLE_CACHE')) {
			return false;
		}

		$this->servers = Configure::read('memcache_servers');

		$this->_Memcache = new Memcache();

		// several servers - use addServer
		foreach ($this->servers as $server) {
			$host = $server[0];
			$port = ((isset($server[1])) ? $server[1] : 11211); // default port

			$this->_Memcache->addServer($host, $port);
		}

		return;
	}

    function use_cache($controller,$key) {
	    if ($this->get($key) === false) {
            return false;
        } else {
            return $this->get($key);
        }
    }

    /*
     * Set a value in the cache
     */
    function set($key, $var, $expires = false) {
        if (defined('DISABLE_CACHE') || !$this->_connected) {
		    return false;
	    }

		$key = $this->scrub_key($key);

		if (!is_numeric($expires)) {
			$expires = strtotime($expires);
		}

        //  check if we want to cache for ever
        //  ----------------------------------
        if(!$expires) {
            $expires = 0;
        }

		if (MEMCACHE_CLIENT) {
			$this->_Memcache->set($key, $var, 0, $expires);
		} else {
			$this->_Memcached->set($key, $var, $expires);
		}

		$this->check_result($key, "Set");

		if ($this->debug && $this->_Memcached->getResultCode() != Memcached::RES_SUCCESS) {
			error_log('[MEMCACHE SET ERROR]['.date('Y-m-d H:i:s').'] '.$this->_Memcached->getResultMessage().' with key '.$key);
		}

        return 1;
    }

    /*
     * Set a value in the cache
     */
    function cas($cas_token, $key, $var, $expires = false) {
        if (defined('DISABLE_CACHE') || !$this->_connected) {
		    return false;
	    }

		$key = $this->scrub_key($key);

		if (!is_numeric($expires)) {
			$expires = strtotime($expires);
		}

        //  check if we want to cache for ever
        //  ----------------------------------
        if(!$expires) {
            $expires = 0;
        }

		$rc = $this->_Memcached->cas($cas_token, $key, $var, $expires);

		$this->check_result($key, "Cas");

        return $rc;
    }

	/*
	 * Add a key
	 */
	function add($key, $value, $expires = false) {
	    if (defined('DISABLE_CACHE') || !$this->_connected) {
		    return false;
	    }

		$key = $this->scrub_key($key);

		if (!is_numeric($expires)) {
			$expires = strtotime($expires);
		}

        //  check if we want to cache for ever
        //  ----------------------------------
        if(!$expires) {
            $expires = 0;
        }

		$rc = $this->_Memcached->add($key, $value, $expires);
		$this->check_result($key, "Add");

		return $rc;
	}

    /*
     * Get a value from cache
     */
    function get($key, &$cas_token = 0) {
	    if (defined('DISABLE_CACHE') || !$this->_connected) {
		    return false;
	    }

		$key = $this->scrub_key($key);

		if (is_array($key)) {
			$rc = $this->_Memcached->getMulti($key, $cas_token);
		} else {
			$rc = $this->_Memcached->get($key, null, $cas_token);
		}
		$this->check_result($key, "Get");

		return $rc;
    }

    /*
     * Remove value from cache
     */
    function delete($key) {
        if (defined('DISABLE_CACHE') || !$this->_connected) {
		    return false;
	    }

		$key = $this->scrub_key($key);

		$rc = $this->_Memcached->delete($key);

		$this->check_result($key, "Delete");

        return $rc;
    }

	/*
	 * Increment/Decrement
	 */
    function increment($key, $amount = 1) {
		$key = $this->scrub_key($key);

	    $rc = $this->_Memcached->increment($key, $amount);

		$this->check_result($key, "Increment");

	    return $rc;
    }

    function decrement($key, $amount = 1) {
		$key = $this->scrub_key($key);

	    $rc = $this->_Memcached->decrement($key, $amount);

		$this->check_result($key, "Decrement");

	    return $rc;
    }

	/*
	 * Stats which are broken
	 */
    function getExtendedStats($item = NULL, $argument = NULL) {
		// Have to use the old API since the new one doesn't support
		// extended stats
		$this->memcache_connect();

	    return $this->_Memcache->getExtendedStats($item, $argument);
    }

    function getSlabStats() {
		return $this->getExtendedStats("slabs");
	    //return $this->_Memcached->getExtendedStats("slabs");
    }

    function dump_all_keys() {
	    $list = array();
	    $allSlabs = $this->getSlabStats();
	    $items = $this->getExtendedStats('items');
	    foreach($allSlabs as $server => $slabs) {
		    foreach($slabs AS $slabId => $slabMeta) {
			    $cdump = $this->getExtendedStats('cachedump',(int)$slabId);

			    foreach($cdump AS $server => $entries) {
				    if($entries) {

					    foreach($entries AS $eName => $eData) {
						    $list[$eName] = array(
							    'key' => $eName,
							    'server' => $server,
							    'slabId' => $slabId,
							    'detail' => $eData,
							    'age' => $items[$server]['items'][$slabId]['age'],
									  );
					    }
				    }
			    }
		    }
	    }
	    ksort($list);

	    echo "Total keys: ".count($list)."<br>";

	    print_r($list);
    }

	function check_result($key, $operation) {
		if (!$this->debug) {
			return;
		}

		$code = $this->_Memcached->getResultCode();
		if ($code != Memcached::RES_NOTFOUND &&
			$code != Memcached::RES_BAD_KEY_PROVIDED &&
			$code != Memcached::RES_SUCCESS &&
			$code != Memcached::RES_DATA_EXISTS) {

			$message = '[MEMCACHE ERROR] ['.date('Y-m-d H:i:s').'] ';

			//if called from command line, these values doesn't exists.
			if(isset($_SERVER['argc']) === FALSE){//if not called from CLI
				$message .= "URL: ".$_SERVER['REQUEST_URI']."\n";
				if (isset($_SERVER['HTTP_REFERER'])) {
					$message .= "Refer: ".$_SERVER['HTTP_REFERER']."\n";
				}
			}

			$message .= "PID: ".getmypid()."\n";
			$message .= "Command: ".$operation."\n";
			$message .= "Key: ".$key."\n";
			$message .= "Code: ".$this->_Memcached->getResultCode()."\n";
			$message .= "Message: ".$this->_Memcached->getResultMessage()."\n";
			$message .= "Date: ".date("r")."\n";
			$message .= "Client Server: ".php_uname()."\n";
			$message .= "M$ Server: ".print_r($this->_Memcached->getServerByKey($key), 1)."\n";

			$this->log_result($message);
			//mail("crowdignite@gorillanation.com", "[BUG] M$ ".$operation." Failure", $message);
			//mail(EMAIL_ADMIN, "[BUG] M$ ".$operation." Failure", $message);
		}
	}

	function log_result($message) {
		if (Configure::read("unit_test")) {
			echo $message;
		} else {
			//CakeLog::write("cake_memcached", $message);
			//plat_assert(false, $message, false);
			error_log($message);
		}
	}

	function _scrub_key($key) {
		return str_replace(" ", "_", $key);
	}

	function scrub_key($key) {
		if (is_array($key)) {
			$count = count($key);
			for ($i = 0; $i < $count; $i++) {
				$key[$i] = $this->_scrub_key($key[$i]);
			}
		} else {
			$key = $this->_scrub_key($key);
		}

		return $key;
	}

}


?>