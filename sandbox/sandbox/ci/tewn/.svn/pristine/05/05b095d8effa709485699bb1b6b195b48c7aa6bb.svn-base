<?php
/**
 * File System File
 *
 * PHP Version 5.3
 *
 * @author   Francisco Gonzalez <francisco.gonzalez@evolvemediallc.com>
 * @license  Evolve Media LLC
 * @link     http://www.crowdignite.com
 */

namespace CI\IO\File;

/**
 * File System Class
 *
 * PHP Version 5.3
 *
 * @author   Francisco Gonzalez <francisco.gonzalez@evolvemediallc.com>
 * @license  Evolve Media LLC
 * @link     http://www.crowdignite.com
 */
class System
{
    protected $nMaxCurlLoop = 20;
    protected $nCurlLoops   = 0;

    /**
     * Generates a new file object using the content
     * get from the path
     *
     * @param  string $sFilePath File path
     *
     * @return \CI\IO\File
     */
    public function read($sFilePath)
    {
        return new \CI\IO\File($sFilePath, file_get_contents($sFilePath));
    }

    public function delete($sFilePath)
    {
        unlink($sFilePath);
    }

    /**
     * Check if exists
     *
     * @param  string $sPath Path to verify
     *
     * @return boolean
     */
    public function exists($sPath)
    {
        return file_exists($sPath);
    }

    /**
     * Write to disk the file
     *
     * @param  \CI\IO\File $oFile      File object to save
     * @param  string      $sFilePath  Path where is gonna be saved
     * @param  boolean     $bOverwrite
     *
     * @return boolean
     */
    public function write(\CI\IO\File $oFile, $sFilePath, $bOverwrite = false)
    {
        if (!$bOverwrite && $this->exists($sFilePath)) {
            throw new Exception(Exception::FILE_ALREADY_EXISTS, $sFilePath);
        }

        return file_put_contents($sFilePath, $oFile->getContent());
    }

    /**
     * Set the max value for the number of tries in the remote request
     *
     * @param integer $nMaxCurlLoop Number of tries for the remote request
     *
     * @return CI\IO\File\System
     */
    public function setMaxCurlLoop($nMaxCurlLoop)
    {
        if (is_int($nMaxCurlLoop)) {
            $this->nMaxCurlLoop = $nMaxCurlLoop;
        }

        return $this;
    }

    /**
     * Return the value for max number of tries in the remote request
     *
     * @return integer
     */
    public function getMaxCurlLoop()
    {
        return $this->nMaxCurlLoop;
    }

    /**
     * Read an external file to be used in the system.
     * @todo This sould be moved to a new class if is used again
     *
     * @param  string $sPath Url of the file to grab
     *
     * @return \CI\IO\File
     */
    public function readRemote($sUrl)
    {
        if (empty($sUrl)) {
            throw new Exception(Exception::ORIGIN_NOT_SET);
        }

        $rCurl = new \CI\Http\Curl();

        try {
            if ($rCurl->allowFollowLocationOpt()) {
                $rCurl->setOpt(CURLOPT_URL, $sUrl);
                $rCurl->setOpt(CURLOPT_RETURNTRANSFER, true);
                $rCurl->setOpt(CURLOPT_CONNECTTIMEOUT, 15);
                $rCurl->setOpt(CURLOPT_FOLLOWLOCATION, true);
                $rCurl->setOpt(CURLOPT_MAXREDIRS, $this->nMaxCurlLoop);
                $mContent = $rCurl->exec();
            } else {
                $mContent = $rCurl->followLocation($sUrl, $this->nMaxCurlLoop);
            }
        } catch (\Exception $oException) {
            throw new Exception(Exception::UNABLE_TO_OPEN_URL, $sUrl . ' message ' . $oException->getMessage());
        }

        $rCurl->close();

        return new \CI\IO\File($sUrl, $mContent);
    }

    public function readRemoteFromStream()
    {
        $oInput = fopen("php://input", "r");
        $sTmpPath = stream_get_meta_data($oInput);
        $mContent = stream_get_contents($oInput);
        fclose($oInput);

        if (false === $mContent) {
            throw new Exception(Exception::UNABLE_TO_OPEN_STREAM);
        }

        return new \CI\IO\File($sTmpPath, $mContent);
    }

    public function createDir($sDir, $nAccess = 0755, $bRecursive = false)
    {
        return mkdir($sDir, $nAccess, $bRecursive);
    }

    public function move($sOldPath, $sNewPath)
    {
        return rename($sOldPath, $sNewPath);
    }

    public function getBaseNameNestedDir($sPath, $nNestedLevel = 1)
    {
        $sReturn = '';
        $aPath = explode("/", $sPath);
        $nTotalDir = count($aPath)-1;

        if ($nNestedLevel > $nTotalDir) {
            $nNestedLevel = $nTotalDir;
        }

        for ($x = ($nTotalDir - $nNestedLevel); $x < $nTotalDir; $x++) {
            $sReturn .=  ($aPath[$x] . '/');
        }

        $sReturn .= $aPath[$nTotalDir];
        return $sReturn;
    }
}