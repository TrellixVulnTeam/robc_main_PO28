<?php
include_once (ROOT . DS . APP_DIR . DS . "global_defines.php");
include_once (ROOT . DS . APP_DIR . DS . "controllers/engine_controller.php");

class ContextualEngineController extends EngineController {

	var $name = 'ContextualEngine';
	var $uses = array('Website', 'Page', 'HistoryTimer','ContextualEngine', 'Account', 'Widget', 'WidgetAnalytic', 'Setting');
	var $helpers = array("Ajax", "Form", "Html", "Convert");
	var $components = array('RequestHandler', 'Statistic', "Timer", "Date", "Rule", "Watchdog");

    public function __construct() {
        parent::__construct();
        $oConfig = new \CI\Config();
        $this->Sphinx = new \CI\Search\Sphinx($oConfig->get("sphinx"));
    }

    function beforeFilter() {
		/* History Widget Analytics */
		App::import('Controller', 'HistoryWidgetAnalytics');
		global $HistoryWidgetAnalytics;
		$HistoryWidgetAnalytics = new HistoryWidgetAnalyticsController;
		$HistoryWidgetAnalytics->constructClasses();

		// Pages
		App::import('Controller', 'Pages');
		global $Page;
		$Page = new PagesController;
		$Page->constructClasses();

		// History Credits
		App::import('Controller', 'HistoryCredits');
		global $HistoryCredits;
		$HistoryCredits = new HistoryCreditsController;
		$HistoryCredits->constructClasses();
		/* Landing Page Engine */
		App::import('Controller', 'LandingPageEngine');
		global $LandingPageEngine;
		$LandingPageEngine = new LandingPageEngineController;
		$LandingPageEngine->constructClasses();

		/* Widget Engine */
		App::import('Controller', 'WidgetEngine');
		global $WidgetEngine;
		$WidgetEngine = new WidgetEngineController;
		$WidgetEngine->constructClasses();

	}

	/* We don't use the engine queue processing in this class */
	function timer_start() {}
	function timer_stop() {}
	function batch_data($batch, $data) {}
	function save_item($identifier, $item) {}

	function load() {
		$this->autoRender = false;
		$pages = $this->Page->find("all",
			array(
				"conditions" => array(
					"visible" => 1,
					"status" => PAGE_STATUS_APPROVED
				)
			)
		);

		foreach ($pages as $page) {
			echo $page['Page']['title']." ";

			$rc = $this->page_add($page);

			if (empty($rc)) {
				echo "Failed: ", $this->Sphinx->getLastResponse();
			} else {
				echo "Success<br>\n";
			}
		}
	}


	public function unload() {
		$this->autoRender = false;
		$statuses = array(
			PAGE_STATUS_DENIED,
			PAGE_STATUS_EXPIRED,
			PAGE_STATUS_PAUSED,
			PAGE_STATUS_DUPLICATE
		);

		$params = array(
			"conditions" => array(
				"visible" => 1
				),
			'fields' => array('id', 'title')
		);

		foreach ($statuses as $status) {
			$params['conditions']['status'] = $status;
			$pages = $this->Page->find("all", $params);
			debug_message('Processing '.count($pages).' Pages');

			foreach ($pages as $page) {
				if ($this->Sphinx->removePage($page['Page']['id'])) {
					debug_message('Removed Page '.$page['Page']['title']);
				}
			}
		}

		debug_message('Done');
	}

	function page_add($page) {
		return $this->Sphinx->addPage(
			$page['Page']['id'],
			$page['Page']['title'],
			$page['Page']['description'],
			$page['Page']['website_id'],
			$page['Page']['domain_bitfield'],
			$page['Page']['category'],
			$page['Page']['demographic_sex'],
			$page['Page']['content_rating']
		);
	}

	function page_remove($page_id) {
		return $this->Sphinx->removePage($page_id);
	}

	function query($term, $website, $limit, $allow_websites = array()) {
		$rc = $this->Sphinx->query($term,
				$website['Website']['domain_primary'],
				$website['Website']['id'],
				$website['Website']['category'],
				$website['Website']['demographic_sex'],
				$website['Website']['content_rating'],
				$limit,
				$allow_websites
		);

		if ($rc) {
			return $rc;
		} else {
			return array();
		}
	}

	public function rebalance_website_chunks($chunk_number, $force = 0) {
		$this->autoRender = false;
		Configure::write('debug', 1);

		/* Setup timers and limits */
		$this->set_chunk_limits($chunk_number);

		$websites = $this->Website->running();

		$website_chunks = $this->chunkify_websites($websites, CONTEXTUAL_MATCHING_CHUNK_NUM);

		$chunk = $website_chunks[$chunk_number-1];

		$this->match_websites($chunk, $force);

		echo "Matched: ".count($chunk);

		$data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);

	}

	private function chunkify_websites($websites, $num_chunks) {
		$chunks = array();
		$i = 0;

		foreach ($websites as $website) {
			$chunks[$i % $num_chunks][] = $website;
			$i++;
		}

		return $chunks;
	}

	private function set_chunk_limits($chunk_number) {
		switch ($chunk_number) {
		case 1:
			$timer = TIMER_CONTEXTUAL_MATCHING_CHUNK1;
			$time_limit = TIME_LIMIT_CONTEXTUAL_MATCHING_CHUNK1;
			$memory_limit = MEMORY_LIMIT_CONTEXTUAL_MATCHING_CHUNK1;
			break;
		case 2:
			$timer = TIMER_CONTEXTUAL_MATCHING_CHUNK2;
			$time_limit = TIME_LIMIT_CONTEXTUAL_MATCHING_CHUNK2;
			$memory_limit = MEMORY_LIMIT_CONTEXTUAL_MATCHING_CHUNK2;
			break;
		case 3:
			$timer = TIMER_CONTEXTUAL_MATCHING_CHUNK3;
			$time_limit = TIME_LIMIT_CONTEXTUAL_MATCHING_CHUNK3;
			$memory_limit = MEMORY_LIMIT_CONTEXTUAL_MATCHING_CHUNK3;
			break;
		case 4:
			$timer = TIMER_CONTEXTUAL_MATCHING_CHUNK4;
			$time_limit = TIME_LIMIT_CONTEXTUAL_MATCHING_CHUNK4;
			$memory_limit = MEMORY_LIMIT_CONTEXTUAL_MATCHING_CHUNK4;
			break;
		default:
			plat_assert(0);
		}

		$this->Timer->start($timer);
		set_time_limit($time_limit);
		ini_set('memory_limit', $memory_limit.'M');
	}

	/* Look just at the new pages */
    function engine_new($cycles = 1, $sleep = 10) {
		$this->autoRender = false;
        $watch_key = 'contextual_engine_engine_new';


        if ($this->Watchdog->is_alive($watch_key)) {
            echo 'The script ', $watch_key, ' is still alive.', PHP_EOL;
            return;
        }

        $this->Watchdog->heartbeat($watch_key);
        Configure::write('debug', 1);
		set_time_limit(TIME_LIMIT_CONTEXTUAL_MATCHING_NEW);
		ini_set('memory_limit', MEMORY_LIMIT_CONTEXTUAL_MATCHING_NEW.'M');

        // Start cycles
        do {
            // Should we stop
            if ($this->Watchdog->needs_to_stop($watch_key)) {
                break;
            }

            $this->Timer->start(TIMER_CONTEXTUAL_MATCHING_NEW);

            // How far back to look for new links
            $time = $this->Date->get_time_minutes_before((TIME_LIMIT_CONTEXTUAL_MATCHING_NEW/60)*2);

            $pages = $this->Page->get_latest($time, 2 /* min number impressions */);

            $script_total = count($pages);
            $script_count = 0;
            $this->Timer->progress_set(0);
            $this->Timer->running_set();
            $oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
            foreach ($pages as $page) {
                $this->Watchdog->heartbeat($watch_key);
                $time_start = microtime(true);

                $website = $this->Website->findById($page['Page']['website_id']);
				$domain_bitfield = $website['Website']['domain_bitfield'];

                $this->Watchdog->heartbeat($watch_key);
                $accounts = $this->accounts_get($domain_bitfield, $website);

                $this->Watchdog->heartbeat($watch_key);
                $this->match($page, $accounts, 0, $website);
                $this->Watchdog->heartbeat($watch_key);

                $script_count++;
                $this->Timer->progress_set($script_count, $script_total);
                $this->Timer->running_set();
            }

            $cycles--;

            echo "Remain cycles: $cycles \n";

            $data = $this->Timer->set_memory_limit();
            $this->Timer->stop_save($data);

            echo 'Sleeping '.$sleep.' seconds before next cycle... ' . PHP_EOL;
            sleep($sleep);
            echo 'Done' . PHP_EOL;
        } while($cycles > 0);

        $this->Watchdog->stop($watch_key);
    }

    public function stop_engine_new($delete_lock = 0) {
        $this->autoRender = false;
        $watch_key        = 'contextual_engine_engine_new';

        if ($delete_lock) {
            $this->Watchdog->stop($watch_key);
            echo 'Deleted lock for script /contextual_engine/engine_new' . PHP_EOL;
        } else {
           $this->Watchdog->stop_process('contextual_engine_engine_new');
           echo 'Stoping /contextual_engine/engine_new in next cycle.' . PHP_EOL;
        }
    }

	function engine($website_id = 0, $force = 0) {
		$this->autoRender = false;
		Configure::write('debug', 1);
		$this->Timer->start(TIMER_CONTEXTUAL_MATCHING);
		set_time_limit(TIME_LIMIT_CONTEXTUAL_MATCHING);
		ini_set('memory_limit', MEMORY_LIMIT_CONTEXTUAL_MATCHING.'M');

		if ($website_id) {
			$force = 1;
		}

		if (!$website_id) {
			$websites = $this->Website->running();
		} elseif ($website_id) {
			$websites = $this->Website->findAllById($website_id);
		}

		$this->match_websites($websites, $force);

		$data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);

	}

	/* Look just at the active pages */
	function engine_active() {
		$this->autoRender = false;
		Configure::write('debug', 1);
		$this->Timer->start(TIMER_CONTEXTUAL_MATCHING_ACTIVE);
		set_time_limit(TIME_LIMIT_CONTEXTUAL_MATCHING_ACTIVE);
		ini_set('memory_limit', MEMORY_LIMIT_CONTEXTUAL_MATCHING_ACTIVE.'M');

		$pages = $this->Page->get_approved();

		$script_total = count($pages);
		$script_count = 0;
		$this->Timer->progress_set(0);
		$this->Timer->running_set();
		$oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
		foreach ($pages as $page) {
			$time_start = microtime(true);

			$website = $this->Website->findById($page['Page']['website_id']);
			$domain_bitfield = $website['Website']['domain_bitfield'];
			$accounts = $this->accounts_get($domain_bitfield, $website);

			$this->match($page, $accounts, 0, $website);

			$script_count++;
			$this->Timer->progress_set($script_count, $script_total);
			$this->Timer->running_set();
		}

		$data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);
	}

	function engine_queue() {
		$this->autoRender = false;
		Configure::write('debug', 1);
		$this->Timer->start(TIMER_CONTEXTUAL_MATCHING_QUEUE);
		set_time_limit(TIME_LIMIT_CONTEXTUAL_MATCHING_QUEUE);
		ini_set('memory_limit', MEMORY_LIMIT_CONTEXTUAL_MATCHING_QUEUE.'M');

		if (Configure::read('queue_kestrel')) {
			App::import('Component', 'QueueKestrel');
			$this->Queue =& new QueueKestrelComponent("contextual_match");
		} else {
			App::import('Component', 'Queue');
			$this->Queue =& new QueueComponent("contextual_match");
		}

		// Pull instance counts from memcached
		$rc = $this->Queue->lock();
		if ($rc) {
			// Lock is taken. Try again later
			echo "Lock taken";
			exit();
		}

		$oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
		do {
			$url = $this->Queue->pop();
			if ($url) {
				echo "Popped: ".$url."<br>\n";
				$page = $this->Page->findByUrl($url);
				if (!$page) {
					continue;
				}

				$website = $this->Website->findById($page['Page']['website_id']);
				$domain_bitfield = $website['Website']['domain_bitfield'];
				$accounts = $this->accounts_get($domain_bitfield, $website);

				$match = $this->match($page, $accounts, 0, $website);
			}
			$this->Queue->lock(1);
		} while ($url);
		$this->Queue->unlock();

		$data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);
	}

	function memcache_engine_queue()
	{
		Configure::write('queue_kestrel', 0);
		$this->engine_queue();
	}

	private function match_websites($websites, $force) {
		$script_total = count($websites);
		$script_count = 0;
		$this->Timer->progress_set(0);
		$this->Timer->running_set();

		foreach ($websites as $website) {
			// Get widgets
			$widgets = $this->get_widgets($website['Website']['id']);

			if (!$widgets) {
				continue;
			}

			// Get elgible websites for this website
			$accounts = $this->accounts_get($website['Website']['domain_bitfield']);

			// Get pages to do matching on
			$pages = $this->get_pages($website['Website']['id']);
			echo 'Procesing ', count($pages), ' pages...', "<br/>\n";
			foreach ($pages as $page) {
				$this->match($page, $accounts, $force, $website);
			}

			$script_count++;
			$this->Timer->progress_set($script_count, $script_total);
			$this->Timer->running_set();
		}
	}

	private function match($page, $accounts, $force = 0, $website = null) {
		// Get website if null
		if ($website == null) {
			$website = $this->Website->findById($page['Page']['website_id']);
		}

		// Get number of links
		$min_num_links_needed = $this->get_num_links_needed();
		$num_links_want = $min_num_links_needed * 2;

		// Get title
		$page['Page']['title_regex'] = $website['Website']['title_regex'];
		$title = $this->get_title($page);
		if (!$title) {
			return 1;
		}

		// Query
		$allow_websites = array();
		foreach ($accounts as $account) {
			$allow_websites[] = $account['Account']['website_id'];
		}
		$links = $this->query($title, $website, $num_links_want, $allow_websites);

		$links = $this->prune_links($page, $links);

		if (count($links) < $min_num_links_needed) {
			echo $page['Page']['url']." - ".$title." - Not enough links: ".count($links)." < ".$min_num_links_needed." <br>\n";
			return 0;
		}

		foreach ($links as $link) {
			echo " ".$website['Website']['name'].": ".$link->weight." - ".$title." - ".$link->title."<br>\n";
		}

		// Order links
		$links = $this->order_links($links, $accounts);

		// Pick links to use and put into array to save
		$links = $this->pick_links($links, $accounts);

		// Save
		$this->save_links($links, $page);

		return 1;
	}

	private function get_widgets($website) {
		$conditions = array('website_id' => $website,
							"status" => WIDGET_STATUS_ACTIVE,
							"visible" => 1);
		return $this->Widget->find("all", array("conditions" => $conditions));
	}

	private function check_links($page, $widgets) {

		foreach ($widgets as $widget) {
			$rc = $this->ContextualEngine->get_page_links_cache($widget['Widget']['id'], $page['Page']['url']);
			if (!$rc) {
				return 0;
			}
		}

		return 1;
	}

	private function save_links($links, $page) {
		global $LandingPageEngine;
		global $WidgetEngine;

		$page_id = $page['Page']['id'];

		/* Widgets */
		foreach ($links as $link) {
			$WidgetEngine->widgets_add($link, LINK_TYPE_CONTEXTUAL, $page_id);
		}

		/* Landing Page */
		// See if this is something we add to landing pages
		if ($page['Page']['status'] != PAGE_STATUS_APPROVED) {
			return;
		}

		foreach ($links as $link) {
			$LandingPageEngine->landing_pages_add($link, LINK_TYPE_CONTEXTUAL, $page_id);
		}
	}

	/* Order contextual matches by SLA & CTR */
	private function order_links($links, $accounts) {
		global $HistoryWidgetAnalytics;

		/* Get score for links SLA */
		$account_count = count($accounts);
		$link_count = count($links);

		for ($i = 0; $i < $link_count; $i++) {
			$account_index = $this->get_account_index($links[$i]->website_id, $accounts);
			if ($account_index == -1) {
				unset($links[$i]);
			}

			if ($account_count) {
				$links[$i]->sla_score = ($account_count - $i) / $account_count;
			} else {
				$links[$i]->sla_score = 0;
			}
		}

		$tmp = array();

		// Take out bad links
		for ($i = 0; $i < $link_count; $i++) {
			if (!isset($links[$i]->id)) {
				continue;
			}

			$tmp[] = $links[$i];
		}

		$links = $tmp;
		$link_count = count($links);

		/* Get match score */
		$match_score = 0;

		// Get max score
		for ($i = 0; $i < $link_count; $i++) {
			if ($links[$i]->weight > $match_score) {
				$match_score = $links[$i]->weight;
			}
		}

		// Normalize score
		for ($i = 0; $i < $link_count; $i++) {
			$links[$i]->match_score = $links[$i]->weight / $match_score;
		}

		/* Do weighted average of score */
		for ($i = 0; $i < $link_count; $i++) {
			$sla_score = $links[$i]->sla_score * $this->Setting->get('CONTEXTUAL_SLA_WEIGHT');
			$match_score = $links[$i]->match_score * $this->Setting->get('CONTEXTUAL_MATCH_WEIGHT');
			$links[$i]->score = $sla_score + $match_score;
		}

		/* Do final ordering based on weighted average */
		uasort($links, "contextual_score_rate");

		return $links;
	}

	private function get_account_index($website_id, $accounts) {
		$count = count($accounts);
		for ($i = 0; $i < $count; $i++) {
			if ($accounts[$i]['Account']['website_id'] == $website_id) {
				return $i;
			}
		}

		return -1;
	}

	private function pick_links($links) {
		$out = array();

		foreach ($links as $link) {
//			if ($link->weight >= CONTEXTUAL_MINIMUM_SCORE) {
				$out[] = $link->id;
//			}
		}

		return $out;
	}

	private function get_num_links_needed() {
		return DEFAULT_WIDGET_CONTEXTUAL_LINKS_MAX;
	}

	private function get_title($page) {
		global $Page;

		if (empty($page['Page']['title'])) {
			$title = $Page->scrape_title($page);
		} else {
			$title = $page['Page']['title'];
		}

		return $title;
	}

	private function get_pages($website_id) {
		$popular_limit = 1000;
		$new_limit = 200;

		$params = array(
			"conditions" => array(
				"website_id" => $website_id,
				"visible" => 1
			),
			'fields' => array('url', 'id', 'title', 'website_id', 'category', 'content_rating', 'status'),
			"order" => "impressions DESC",
			"limit" => $popular_limit
		);

		$pages_popular = $this->Page->find("all", $params);

		if (count($pages_popular) < $popular_limit) {
			return $pages_popular;
		}

		$params['conditions']['impressions <'] = 5;
		$params['limit'] = $new_limit;

		$pages = $this->Page->find("all", $params);

		if (empty($pages)) {
			$pages = array();
		}

		if ($pages_popular) {
			foreach ($pages_popular as $page) {
				$pages[] = $page;
			}
		}

		return $pages;
	}

	function account_skip($account, $website) {
		if ($website && ($website['Website']['account_id'] == $account['Account']['id'])) {
			return 1;
		}

		return 0;
	}

	private function prune_links($page, $links) {
		$out_links = array();

		foreach ($links as $link) {
			if ($this->business_rules_allowed($page, $link)) {
				$out_links[] = $link;
			}
		}

		return $out_links;
	}

	private function business_rules_allowed($page, $link) {
		// Category
		if ($page['Page']['category'] && !$this->Rule->category($page['Page']['category'], $link->category)) {
			return 0;
		}

		// Content
		if (!$this->Rule->content_rating($page['Page']['content_rating'], $link->content_rating)) {
			return 0;
		}

		return 1;
	}

	public function test() {
		$website = $this->Website->findById(1161);
		$oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
		$domain_bitfield = $website['Website']['domain_bitfield'];
		$accounts = $this->accounts_get($domain_bitfield, $website);

		$pages = $this->Page->findAllByWebsiteId($website['Website']['id']);
		foreach ($pages as $page) {
			$this->match($page, $accounts, 1, $website);
		}
	}
}

function contextual_lp_incoming_rate($a, $b) {
	if ($a['incoming'] == $b['incoming']) {
		return 0;
	}
	return ($a['incoming'] > $b['incoming']) ? -1 : 1;
}

function contextual_w_ctr_rate($a, $b) {
	if ($a->ctr == $b->ctr) {
		return 0;
	}
	return ($a->ctr > $b->ctr) ? -1 : 1;
}

function contextual_score_rate($a, $b) {
	if ($a->score == $b->score) {
		return 0;
	}
	return ($a->score > $b->score) ? -1 : 1;
}

?>
