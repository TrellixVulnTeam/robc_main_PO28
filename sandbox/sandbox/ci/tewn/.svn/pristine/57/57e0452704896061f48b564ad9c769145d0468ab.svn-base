<?php
include_once (ROOT . DS . APP_DIR . DS . "global_defines.php");

class RankerController extends AppController {

	var $name = 'Ranker';
	var $uses = array('Website', 'Page', 'Ranker', 'User', 'Setting');
	var $helpers = array("Ajax", "Form", "Html", "Convert");
	var $components = array('RequestHandler', 'Statistic', 'Domain', "Timer", "Date");

	function beforeFilter() {
		$this->Session->activate();
		$user = $this->Session->read('User');
		$this->set_types_user($user);

		App::import('Controller', 'LandingPage');
		global $LandingPage;
		$LandingPage = new LandingPageController;
		$LandingPage->constructClasses();

		App::import('Controller', 'HistoryPages');
		global $HistoryPage;
		$HistoryPage = new HistoryPagesController;
		$HistoryPage->constructClasses();
	}

	function index($category, $number_links = 5) {
		global $LandingPage;
		Configure::write('debug', 0);

		$category = intval($category);
		$number_links = intval($number_links);

		$links = $this->get_links(DOMAIN_ID, $category, $number_links);

		/* Crop Images */
		$width = 300;
		$height = 200;

		/* Create JSON Pages */
		$i = 0;
		$out = array();

		foreach ($links as $link) {
			$tmp = $LandingPage->create_canonical_page($link, $width, $height);
			$out[$i]['link'] = $tmp['url'];
			$out[$i]['title'] = $tmp['title'];
			$out[$i]['trending'] = ($tmp['rank'] >= $tmp['rank_prior']) ? 1 : 0;
			$out[$i]['image'] = $tmp['image'];
			$i++;
		}

		$this->layout = "json";

		$this->set("json_data", json_encode($out));
	}

	function view($category, $number_links = 5, $domain_id = DOMAIN_ID) {
		$this->Session->activate();
		$user = $this->Session->read('User');
		$user = $this->User->findById($user['id']);

		$category = intval($category);
		$number_links = intval($number_links);
		$domain_bit = intval($domain_id);

		$links = $this->get_links($domain_id, $category, $number_links);

		//$this->layout = DOMAIN.'/default';
		$this->layout = 'backend2';
		$this->set("links", $links);
		$this->set("category", $category);
		$this->set("num_links", $number_links);
		$this->set("hub", $domain_bit);

		$oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
		$this->set("domain_component", $oHub);
		$this->set('user', $user);
	}

	function get_links($domain_id, $category, $number_links) {
		$content_rating = array(WEBSITE_CONTENT_G, WEBSITE_CONTENT_PG13);
		$status = PAGE_STATUS_APPROVED;

		$oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
		$domain_bitfield = $oHub->idToBit($domain_id);

		$subcategory = null;
		$page = 1;
		$limit = $number_links;
		$ranked_at_website_level = null;

		$links = $this->Page->get_by_rank($status, $content_rating, $domain_bitfield, $category, $subcategory, $page, $limit, $ranked_at_website_level);

		return $links;
	}

	function engine($full = 1, $domain_id = NULL, $pending = 0) {
		$this->autoRender = false;

		/* Timers & Limits */
		if ($pending == 0) {
			$this->Timer->start(TIMER_RANKER_ENGINE);
			set_time_limit(TIME_LIMIT_RANKER_ENGINE);
			ini_set('memory_limit', MEMORY_LIMIT_RANKER_ENGINE.'M');
		} else {
			$this->Timer->start(TIMER_RANKER_PENDING_ENGINE);
			set_time_limit(TIME_LIMIT_RANKER_PENDING_ENGINE);
			ini_set('memory_limit', MEMORY_LIMIT_RANKER_PENDING_ENGINE.'M');
		}

		/* Getting websites */
		$conditions = array(
			"visible" => 1,
			"status" => WEBSITE_STATUS_ACTIVE
		);

		if (!$full) {
			// if not full only ranked
			$conditions['ranked'] = 1;
		}

		if ($domain_id) {
			// for some domain only
			$conditions['domain_primary'] = $domain_id;
		}

		$websites = $this->Website->find(
			'all',
			array(
				"conditions" => $conditions,
				"fields" => array('Website.id, Website.name')
			)
		);

		// Setting pages conditions
		$conditions = array(
			'visible' => TRUE,
			'status' => PAGE_STATUS_APPROVED,
		);

		// if not full only ranked
		if (!$full) {
			$conditions['ranked'] = 1;
		}

		if ($pending) {
			$conditions['status'] = PAGE_STATUS_PENDING;
			$conditions['impressions >='] = $this->Setting->get('RANK_MINIMUM_IMPRESSIONS');
		}

		$script_total = count($websites);
		$script_count = 0;
		$this->Timer->progress_set(0);
		$this->Timer->running_set();

		debug_memory('Processing '.$script_total.' Websites');

		foreach ($websites as $website) {
			$conditions['website_id'] = $website['Website']['id'];

			$pages = $this->Page->find('all',
				array(
					'conditions' => $conditions,
					'fields' => array('Page.id', 'Page.created', 'Page.website_id', 'Page.rank', 'Page.url')
				)
			);
			debug_memory('Processing '.count($pages).' Pages from Website '.$website['Website']['name'].' ['.$website['Website']['id'].']');

			// Getting std DEV of the website
			$Date = new \CI\Date();
			$date = $Date->getDaysAgo($this->Setting->get('RANK_TRAFFIC_HISTORY'));
			$website_stddev = $this->Ranker->get_website_stats_cache($website['Website']['id'], $date);
			if (empty($website_stddev)) {
				$traffic = $this->get_website_traffic($date, $website['Website']['id']);
				if (empty($traffic)) {
					$website_stddev = array('mean' => 0, 'stddev' => 0);
				} else {
					$website_stddev = array(
						'mean' => array_sum($traffic) / count($traffic),
						'stddev' => $this->Statistic->standard_deviation_population($traffic),
					);
				}
				$this->Ranker->set_website_stats_cache($website['Website']['id'], $date, $website_stddev);
			}

			// Ranking pages from website
			$ranked_pages = array();
			foreach ($pages as $page) {
				if (isset($ranked_pages[$page['Page']['url']])) {
					continue;
				}
				$this->rank($page, $website_stddev);
				$ranked_pages[$page['Page']['url']] = true;
				echo '.';
			}
			unset($ranked_pages, $pages);
			echo PHP_EOL;

			// Update the Timer processor
			$script_count++;
			$this->Timer->progress_set($script_count, $script_total);
			$this->Timer->running_set();
		}

		/* Save off timer */
		$data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);

		debug_message('Done');
	}

	public function pending_chunk($chunk_number)
	{
		if ($chunk_number <= 0 || $chunk_number > RANKER_PENDING_CHUNK_NUM) {
			echo 'There is no chunk ', $chunk_number, '... Quiting...';
			exit;
		}
		$websites_count = $this->Website->find('count', array('conditions' => array('visible' => true)));
        $website_chunk = intval($websites_count / RANKER_PENDING_CHUNK_NUM);
		$websites = $websites = $this->Website->find(
            'all',
            array(
                'conditions' => array(
                    'visible' => true,
                ),
                'fields' => 'id, name',
                'order' => 'id',
                'offset' => ($website_chunk * ($chunk_number - 1)),
                'limit' => $website_chunk,
            )
        );

		$this->Timer->start(constant('TIMER_RANKER_PENDING_CHUNK'.$chunk_number));
		set_time_limit(TIME_LIMIT_RANKER_PENDING_CHUNK);
		ini_set('memory_limit', MEMORY_LIMIT_RANKER_PENDING_CHUNK.'M');

        debug_memory('Ranking pending pages from '.count($websites).' Websites');

        $script_total = count($websites);
    	$script_count = 0;
        $this->Timer->progress_set(0);
    	$this->Timer->running_set();
        foreach ($websites as $website) {
        	$this->rank_website($website['Website']['id'], 1/* Pending */);
        	$script_count++;
			$this->Timer->progress_set($script_count, $script_total);
			$this->Timer->running_set();
        }
        $data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);
        debug_memory('Done');
	}

	public function rank_website($website, $pending = 1)
	{
		$this->autoRender = false;

		if (is_numeric($website)) {
			$website = $this->Website->findById($website);
		}

		// Setting pages conditions
		$conditions = array(
			'visible'    => TRUE,
			'status'     => PAGE_STATUS_APPROVED,
			'website_id' => $website['Website']['id'],
			'ranked'     => 1,
		);

		if ($pending) {
			$conditions['status'] = PAGE_STATUS_PENDING;
			$conditions['impressions >='] = $this->Setting->get('RANK_MINIMUM_IMPRESSIONS');
		}

		$pages_page  = 1;
		$pages_chunk = 1000;
		$total_pages = $pages = $this->Page->find('count', array('conditions' => $conditions));
		echo 'Processing ', $total_pages, ' Pages from Website '.$website['Website']['name'].' ['.$website['Website']['id'].']:';

		if (0 !== $total_pages) {
			// Getting std DEV of the website
			$website_stddev = $this->get_website_stddev($website['Website']['id']);

			do {
				$pages = $this->Page->find(
					'all',
					array(
						'fields'     => array('Page.id', 'Page.created', 'Page.website_id', 'Page.rank', 'Page.url'),
						'conditions' => $conditions,
						'limit'      => $pages_chunk,
						'page'       => $pages_page++,
					)
				);

				$count_pages = count($pages);
				if (empty($pages)) {
					break;
				}

				// Ranking pages from website
				$ranked_pages = array();
				foreach ($pages as $page) {
					if (isset($ranked_pages[$page['Page']['url']])) {
						continue;
					}
					$this->rank($page, $website_stddev);
					$ranked_pages[$page['Page']['url']] = true;
				}
				unset($ranked_pages, $pages);
				echo '.';
			} while($count_pages == $pages_chunk);
		}
		debug_memory('Done');
	}

	protected function get_website_stddev($website_id)
	{
		$Date = new \CI\Date();
		$date = $Date->getDaysAgo($this->Setting->get('RANK_TRAFFIC_HISTORY'));
		$website_stddev = $this->Ranker->get_website_stats_cache($website_id, $date);
		if (empty($website_stddev)) {
			$traffic = $this->get_website_traffic($date, $website_id);
			if (empty($traffic)) {
				$website_stddev = array('mean' => 0, 'stddev' => 0);
			} else {
				$website_stddev = array(
					'mean' => array_sum($traffic) / count($traffic),
					'stddev' => $this->Statistic->standard_deviation_population($traffic),
				);
			}
			$this->Ranker->set_website_stats_cache($website_id, $date, $website_stddev);
		}
		return $website_stddev;
	}

	/*
	 * This rank algorithm is loosly based on the Reddit ranking algorithm.
	 *
	 * It is broken into two components:
	 *
	 *	1.) Relative Traffic of a page for a website
	 *	2.) Time decay on how recent the post was made
	 *
	 * The relative traffic is the number of standard deviations a page is
	 * away from the average page on a site.
	 *
	 * The time decay is done by watering down old posts and giving a higher
	 * rank to newer posts
	 *
	 */
	private function rank($page, $website_stddev) {
		global $HistoryPage;

		/* Time Since Added */
		$time_diff = $this->get_time($page);
		$time = $time_diff / $this->Setting->get('RANK_RELEVANT_PERIOD');

		/* Get standard deviations from website's traffic */
		$traffic_stddev = 0;
		if ($website_stddev['stddev'] > 0) {
			$page_stats = $HistoryPage->stats_days($page['Page']['id'], $this->Setting->get('RANK_TRAFFIC_PERIOD'));
			$traffic_stddev = ($page_stats['impressions'] - $website_stddev['mean']) / $website_stddev['stddev'];
		}
		$traffic = $traffic_stddev * $this->Setting->get('RANK_TRAFFIC_CONSTANT');

		/* Calculate rank */
		$rank = $traffic + $time;

		/* Save ranking off */
		$this->Page->id = $page['Page']['id'];
		$this->Page->save(
			array(
				'Page' => array(
					'rank_prior' => $page['Page']['rank'],
					'rank' => $rank,
				),
			)
		);
	}

	private function get_website_traffic($date, $website_id) {
		global $HistoryPage;

		$traffic = array();
		$sites_pages = $this->Page->get_rankable_pages($date, $website_id);

		foreach ($sites_pages as $id => $page_id) {
			$tmp = $HistoryPage->stats_days($page_id, $this->Setting->get('RANK_TRAFFIC_HISTORY'));
			if (empty($tmp)) {
				continue;
			}

			$traffic[] = $tmp['impressions'];
		}

		return $traffic;
	}

	private function get_traffic_stddev($page) {
		global $HistoryPage;

		$date = $this->Date->days_ago($this->Setting->get('RANK_TRAFFIC_HISTORY'));

		// Check cache
		$cache = $this->Ranker->get_website_stats_cache($page['Page']['website_id'], $date);
		if ($cache) {
			$stddev = $cache['stddev'];
			$mean = $cache['mean'];
		} else {
			$traffic = $this->get_website_traffic($date, $page['Page']['website_id']);
			if (!count($traffic)) {
				return 0;
			}

			$stddev = $this->Statistic->standard_deviation_population($traffic);
			debug_message('Standard Deviation: '.$stddev);

			$mean = array_sum($traffic) / count($traffic);

			// Set cache
			$this->Ranker->set_website_stats_cache($page['Page']['website_id'], $date, array("stddev" => $stddev, "mean" => $mean));
		}

		if (!$stddev) {
			return 0;
		}

		$page_stats = $HistoryPage->stats_days($page['Page']['id'], $this->Setting->get('RANK_TRAFFIC_PERIOD'));

		return ($page_stats['impressions'] - $mean) / $stddev;
	}

	private function get_time($page) {
		// This just has to be some base number. It could be anything in the past
		$rank_algorithm_epoc = strtotime("2010-02-22");

		$page_seconds = strtotime($page['Page']['created']);

		return $page_seconds - $rank_algorithm_epoc;
	}
}
?>
