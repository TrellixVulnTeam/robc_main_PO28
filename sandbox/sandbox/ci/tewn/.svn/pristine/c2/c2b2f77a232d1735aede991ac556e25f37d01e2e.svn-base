<?php
class Website extends AppModel {

	var $name = 'Website';
	var $validate = array(
		'user_id' => array('numeric'),
		'url' => array('rule' => array('url'),
					   'message' => "Invalid URL"),
		'account_id' => array('numeric')
	);

    public function get_visible_by_ids($websites_ids)
    {
        $websites_list = $this->find(
            'all',
            array(
                'fields' => array('id', 'name', 'status', 'domain_primary'),
                'conditions' => array(
                    'id'      => $websites_ids,
                    'visible' => 1,
                ),
                'order' => array('id'),
            )
        );

        $response = array();
        foreach ($websites_list as $website) {
            $response[$website['Website']['id']] = $website['Website'];
        }

        return $response;

    }

    public function get_running_by_hub($hub_ids = null)
    {
        $conditions = array(
            'visible'        => 1,
            'status'         => array(
                WEBSITE_STATUS_ACTIVE,
                WEBSITE_STATUS_INACTIVE,
                WEBSITE_STATUS_NEW,
                WEBSITE_STATUS_TRANSFER,
            ),
        );

        if ($hub_ids !== null) {
            $conditions['domain_primary'] = explode(',', $hub_ids);
        }

        $websites_list = $this->find(
            'all',
            array(
                'fields' => array('id', 'name', 'status', 'domain_primary'),
                'conditions' => $conditions,
                'order' => array('id'),
            )
        );

        $response = array();
        foreach ($websites_list as $website) {
            $response[$website['Website']['id']] = $website['Website'];
        }

        return $response;
    }

    public function get_websites_accounts(array $websites, array $fields = array())
    {
        $websites_list = array();
        if (!empty($websites)) {

            $websites_ids = implode(',', $websites);
            $field_list = 'Website.*, Account.*';
            if (!empty($fields)) {
                $field_list = implode(',', $fields);
            }
            $websites_list = $this->query_read(
                "SELECT {$field_list}
                 FROM websites Website
                    INNER JOIN accounts Account ON Account.website_id = Website.id
                 WHERE Website.id IN ({$websites_ids})", false
            );
        }
        return $websites_list;
    }

    public function get_websites_for_ctp($website_id = null)
    {
        $website_query = is_null($website_id) ? '' : "AND Website.id = {$website_id}";
        return $this->query_read(
            'SELECT Website.id, Website.category, Website.demographic_sex, Website.content_rating,
                GROUP_CONCAT(CONCAT(widgets.id,",",widgets.num_links,",",widgets.height,",",widgets.width) SEPARATOR "|") AS widgets
             FROM websites AS Website INNER JOIN widgets ON Website.id = widgets.website_id AND widgets.status < 2
             WHERE Website.visible = 1 '.$website_query.'
             GROUP BY Website.id',
             false
        );
    }

    public function get_by_id($website_id)
    {
        $key_gen = new CI\Memcached\KeyGen($website_id, 'website_get_by_id', 1);
        $cache_key = $key_gen->generate();
        $website = $this->memcached_get_json($cache_key);

        if (empty($website) && !is_array($website)) {
            $website = $this->findById($website_id);
            if (!empty($website)) {
            	$this->memcached_set_json($cache_key, $website, 10 * 60 /*10 Minutes*/);
            }
        }

        return $website;
    }

	function active($fields = NULL) {
		$params = array("conditions" => array("visible" => true));
		if ($fields) {
			if (is_string($fields)) {
				$fields = array($fields);
			}
			$params['fields'] = $fields;
		}

		$websites = $this->find("all", $params);
		plat_assert($websites);

		return $websites;
	}

	function running($domain_primary = DOMAIN_ID_ALL, $domain_bitfield = 0, $intersect = 0) {
		$conditions = array("status" => array(
								WEBSITE_STATUS_ACTIVE,
								WEBSITE_STATUS_TRANSFER),
							"visible" => true);

		if ($intersect) {
			$conditions['category'] = $intersect['category'];
			$conditions['demographic_sex'] = $intersect['demographic_sex'];
			$conditions['content_rating'] = $intersect['content_rating'];
		}

		if ($domain_primary != -1) {
			$conditions['domain_primary'] = $domain_primary;
		}

		if ($domain_bitfield) {
			$conditions[] = 'domain_bitfield & '.$domain_bitfield;
		}

		$websites = $this->find("all", array("conditions" => $conditions));
		if(!empty($websites)){
			plat_assert($websites);
		}

		return $websites;
	}

	function find_by_widgets($widgets) {
		$website_ids = array();

		foreach ($widgets as $widget) {
			$website_ids[] = $widget['Widget']['website_id'];
		}

		$conditions = array("id" => $website_ids,
							"visible" => true);

		$websites = $this->find("all", array("conditions" => $conditions,
			"group" => "id"
			));

		return $websites;
	}

	function find_new() {
		$websites = $this->find("all", array("conditions" =>
						     array("status" => WEBSITE_STATUS_NEW,
							   "visible" => true)));
		return $websites;
	}

	function is_active($website) {
		switch ($website['Website']['status']) {
		case WEBSITE_STATUS_ACTIVE:
		case WEBSITE_STATUS_NEW:
		case WEBSITE_STATUS_TRANSFER:
			return 1;
		default:
			return 0;
		}
	}

	function get_url_regex($website_id) {
		App::import('Component', 'CakeMemcache');
		$this->CakeMemcache =& new CakeMemcacheComponent(null);

		$key = $this->website_url_regex_key($website_id);

		$regex = $this->CakeMemcache->get($key);

		if (!$regex) {
			$regex = $this->field("url_regex", array("id" => $website_id,
								 "visible" => true));

			plat_assert($regex);

			$this->CakeMemcache->set($key, $regex, 60*60);
		}

		return $regex;
	}

	function invalidate_url_regex($website_id) {
		if (!$website_id) {
			return;
		}

		App::import('Component', 'CakeMemcache');
		$this->CakeMemcache =& new CakeMemcacheComponent(null);

		$key = $this->website_url_regex_key($website_id);

		$regex = $this->CakeMemcache->delete($key);
	}

	function website_url_regex_key($website_id) {
		return "website_url_regex::".$website_id;
	}

	/**
	 * Looks for websites who matches the $term passed as argument
	 *
	 * @param String $term To be used as a term to look for records.
	 * @return Array Data with the accounts that matched
	 */
	public function match($term) {
		$params = array();
		$type = "all";

		$params['conditions'] = array (
			"1=1",
			"OR" => array(
				array("url LIKE" => "%$term%"),
				array("name LIKE" => "%$term%")
			)
		);

		$params['limit'] = 15;
		$params['fields'] = array(
			'id',
			'url',
			'name',
			'account_id'
		);

		return $this->find($type, $params);
	}

	public function social_rebalance_update($website_id) {
		app::import('Component','Date');
		$this->Date = new DateComponent();

		$this->id = $website_id;
		$this->saveField('last_social_rebalance', $this->Date->now());
	}

	public function with_active_widgets($fields = '*') {
		if (is_string($fields)) {
			$fields = explode(',', $fields);
		}

		if (is_array($fields)) {
			for ($i = 0, $total = count($fields); $i < $total; $i++) {
				if (strpos($fields[$i], 'Website.') === false) {
					$fields[$i] = 'Website.'.trim($fields[$i]);
				}
			}
			$fields = implode(', ', $fields);
		}

		$query = 'SELECT '.$fields.'
			FROM websites as Website INNER JOIN (
			    SELECT website_id
			    FROM widgets
			    WHERE status = '.WIDGET_STATUS_ACTIVE.' AND visible = 1
			    GROUP BY website_id) T ON T.website_id = Website.id
			WHERE visible = 1';
		return $this->query_read($query);
	}

	public function get_peer_websites($website) {
	    $oKeyGen = new \CI\Memcached\KeyGen($website['Website'], __METHOD__);
        $cache_key = $oKeyGen->generate();
        $peer_websites = $this->memcached_get_json($cache_key);

        if (0 === $peer_websites) {
    	    $oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
            $conditions = array(
                "Website.domain_bitfield & ".$oHub->idToBit($website['Website']['domain_primary']),
                "Website.visible" => 1,
                "Website.status"  => WEBSITE_STATUS_ACTIVE,
                "Website.id <>"   => $website['Website']['id'],
                "category"        => $website['Website']['category'],
                "demographic_sex" => $website['Website']['demographic_sex'],
            );

            switch ($website['Website']['content_rating']) {
                case WEBSITE_CONTENT_G:
                    $conditions['content_rating <='] = WEBSITE_CONTENT_PG13;
                    break;
                case WEBSITE_CONTENT_PG13:
                    $conditions['content_rating <='] = WEBSITE_CONTENT_R;
                    break;
                case WEBSITE_CONTENT_R:
                    $conditions['content_rating'] = array(WEBSITE_CONTENT_PG13, WEBSITE_CONTENT_R);
                    break;
                case WEBSITE_CONTENT_MENS:
                    $conditions['content_rating'] = WEBSITE_CONTENT_MENS;
                    break;
                default:
            }

            // Bind accounts
            $this->bindModel(
                array(
                    "belongsTo" => array(
                        "Account" => array(
                            'className'  => 'Account',
                            'conditions' => '',
                            'order'      => '',
                            'foreignKey' => 'account_id'
                        )
                    )
                )
            );

            $peer_websites = $this->find(
                "all",
                array(
                    "conditions" => $conditions,
                    "limit"      => 5,
                    "order"      => "Account.incoming DESC"
                )
            );

            $this->memcached_set_json($cache_key, $peer_websites);
        }

        return $peer_websites;
    }

    public function get_peer_websites_trait($website)
    {
        if (empty($website)) {
            plat_assert(false, $website, false);
            return array();
        }
        $oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
        $primary_domain_bit = $oHub->idToBit($website['Website']['domain_primary']);
        if (empty($primary_domain_bit)) {
            plat_assert(false, $website, false);
            return array();
        }
        $content_rating = '';
        switch ($website['Website']['content_rating']) {
            case WEBSITE_CONTENT_G:
                $content_rating = " AND Website.content_rating <= " . WEBSITE_CONTENT_PG13 . ' ';
                break;
            case WEBSITE_CONTENT_PG13:
                $content_rating = " AND Website.content_rating <= " . WEBSITE_CONTENT_R . ' ';
                break;
            case WEBSITE_CONTENT_R:
                $content_rating = " AND Website.content_rating IN (" . WEBSITE_CONTENT_PG13 . ", " . WEBSITE_CONTENT_R . ") ";
                break;
            case WEBSITE_CONTENT_MENS:
                $content_rating = " AND Website.content_rating = " . WEBSITE_CONTENT_MENS . ' ';
                break;
        }
        $query = "SELECT GROUP_CONCAT(id) AS id
            FROM (
                SELECT Website.id AS id
                FROM websites AS Website
                LEFT JOIN accounts AS Account ON (Website.account_id = Account.id)
                WHERE Website.domain_bitfield & {$primary_domain_bit}
                    AND Website.visible = 1
                    AND Website.status = " . WEBSITE_STATUS_ACTIVE . "
                    AND Website.id <> {$website['Website']['id']}
                    AND Website.category = {$website['Website']['category']}
                    AND Website.demographic_sex = {$website['Website']['demographic_sex']}
                    {$content_rating}
                ORDER BY Account.incoming DESC
                LIMIT 5
            ) AS neighbor";

        return $this->query($query, false);
    }

    public function get_rebalance_websites_chunk()
    {
        $query = "SELECT Website.id, Website.name, Website.account_id, Website.domain_primary,
                Website.blacklist, Website.whitelist, Website.allowed_categories_bitfield,
                Website.strict_category, Website.category, Website.subcategory, Website.demographic_sex,
                Website.content_rating, IFNULL(( SELECT COUNT(wa.id) total FROM widget_analytics wa WHERE wa.visible = 1 AND wa.shown_website_id = Website.id ), 0) AS total_pages
            FROM websites AS Website
            INNER JOIN (
                SELECT w.website_id
                FROM widgets w
                WHERE w.visible = 1 AND w.status <> " . WIDGET_STATUS_DELETED . "
                    AND w.last_used >= DATE_SUB(DATE(NOW()), INTERVAL 6 MONTH)
                GROUP BY w.website_id
            ) AS Widgets ON Widgets.website_id = Website.id
            HAVING total_pages > 0";
            return $this->query($query, false);
    }

    public function get_rebalance_website($website_id)
    {
        $query = "SELECT Website.id, Website.domain_primary, Website.domain_bitfield, Website.user_id,
                Website.account_id, Website.status, Website.name, Website.url, Website.landing_page_style_id,
                Website.subdomain, Website.content_rating, Website.category, Website.demographic_sex,
                Website.subcategory, Website.strict_category, Website.allowed_categories_bitfield,
                Website.disable_utm, Website.custom_utm, Website.nice_links, Website.title_regex, Website.url_nofollow,
                Website.url_regex, Website.blacklist, Website.whitelist, Website.ranked, Website.notes, Website.tier,
                Website.last_social_rebalance, Website.modified, Website.created, Website.visible, Website.settings, Website.tracking
            FROM websites AS Website
            WHERE Website.id = {$website_id}
                AND EXISTS ( SELECT 1 FROM widgets AS w WHERE w.website_id = Website.id AND w.visible = 1 AND w.status <> " . WIDGET_STATUS_DELETED . " )";
        return $this->query($query, false);
    }

    public function get_rebalance_websites_full()
    {
        $query = "SELECT Website.id, Website.domain_primary, Website.domain_bitfield, Website.user_id,
                Website.account_id, Website.status, Website.name, Website.url, Website.landing_page_style_id,
                Website.subdomain, Website.content_rating, Website.category, Website.demographic_sex,
                Website.subcategory, Website.strict_category, Website.allowed_categories_bitfield,
                Website.disable_utm, Website.custom_utm, Website.nice_links, Website.title_regex, Website.url_nofollow,
                Website.url_regex, Website.blacklist, Website.whitelist, Website.ranked, Website.notes, Website.tier,
                Website.last_social_rebalance, Website.modified, Website.created, Website.visible, Website.settings, Website.tracking
            FROM websites AS Website
            WHERE Website.visible = 1
                AND EXISTS ( SELECT 1 FROM widgets AS w WHERE w.website_id = Website.id AND w.visible = 1 AND w.status <> " . WIDGET_STATUS_DELETED . " AND w.last_used >= DATE_SUB(DATE(NOW()), INTERVAL 6 MONTH) )";
        return $this->query($query, false);
    }

    /**
     * Return the number of websites for status
     *
     * @return array Array of number of websites in each status
     */
    public function get_count_by_status()
    {
        $return   = array();
        $websites = $this->query_read('SELECT status, COUNT(0) AS total FROM websites GROUP BY status', false);

        foreach ($websites as $website) {
            $index = ($website['websites']['status'] == '') ? -1 : $website['websites']['status'];
            $return[$index] = $website[0]['total'];
        }

        return $return;
    }

    public function get_publisher_tracking($website_id)
    {
        if (false === is_numeric($website_id) && $website_id < 1) {
            return PUBLISHER_TRACKING_DISABLED;
        }

        $cache_key = $this->get_publisher_tracking_cache_key($website_id);
        $tracking = $this->memcached_get($cache_key);

        if (false === $tracking) {
            $website = $this->findById($website_id);
            $tracking = PUBLISHER_TRACKING_DISABLED;

            if (isset($website['Website']['tracking']))
            {
                $tracking = (int) $website['Website']['tracking'];
                $this->memcached_set($cache_key, $tracking, 2 * HOURS);
            }
        }

        return $tracking;
    }

    public function get_publisher_tracking_cache_key($website_id)
    {
        return 'publisher_tracking_key::' . $website_id;
    }

    public function invalidate_website_cache($website_id) {
        $key = "website::".$website_id;
        return $this->memcached_delete($key);
    }

    public function get_websites_report($domain_id, $status, $category)
    {
        $oBit      = new \CI\Bitwise();
        $aInactive = array(
            \CI\Website::WEBSITE_STATUS_PAUSED,
            \CI\Website::WEBSITE_STATUS_INACTIVE
        );

        if ($oBit->contains($aInactive, $status)) {
            $status = \CI\Website::WEBSITE_STATUS_PAUSED . ',' . \CI\Website::WEBSITE_STATUS_INACTIVE;
        }

        $websites = array();
        $sql      = 'CALL ci_ci_sp_select_management_website_list(%d, "%s", %d)';
        $sql      = sprintf($sql, $domain_id, $status, $category);
        $result   = $this->query_read($sql, false);

        if (! empty($result)) {
            foreach($result as $website) {
                $id = (int) $website['websites']['id'];
                $websites[$id] = array(
                    'id'             => $id,
                    'name'           => $website['websites']['name'],
                    'url'            => $website['websites']['url'],
                    'ranked'         => $website['websites']['ranked'],
                    'tier'           => $website['websites']['tier'],
                    'domain_primary' => (int) $website['websites']['domain_primary'],
                    'account_id'     => (int) $website['websites']['account_id'],
                    'tier'           => \CI\Component\Facade\Tier::getValidTier($website['websites']['tier']),
                    'email'          => $website['users']['email'],
                    'rr'             => \CI\Formulas::getReturnRate($website['accounts']['outgoing'], $website['accounts']['incoming']),
                    'incoming'       => (int) $website['accounts']['incoming'],
                    'outgoing'       => (int) $website['accounts']['outgoing'],
                    'credits'        => (int) round($website['accounts']['credits'] / 10),
                    'rate'           => (float) $website['accounts']['rate'],
                    'featured'       => (float) $website['0']['featured'],
                    'page_active'    => (int) $website['0']['page_active'],
                    'page_pending'   => (int) $website['0']['page_pending'],
                    'page_moderate'  => (int) $website['0']['page_pending_moderator']
                );
            }
        }

        return $websites;
    }
}
