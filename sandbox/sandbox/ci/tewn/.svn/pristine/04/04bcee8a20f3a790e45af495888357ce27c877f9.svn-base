
<?php

include_once (ROOT . DS . APP_DIR . DS . "global_defines.php");
include_once (ROOT . DS . APP_DIR . DS . "controllers/engine_controller.php");

global $idToBitfield;
global $url_to_id;

class SimilarEngineController extends EngineController {

	var $name = 'LandingPage';

	var $uses = array('Account', 'Website', 'LandingPageAnalytic', 'Page', 'Log', 'SimilarEngine', 'Setting');
	var $components = array('Trace', 'Intersects', 'Analytic', 'Timer', 'Date', 'Rule');

	var $accounts_lp = NULL;

	function beforeFilter() {
		// History Landing Page Analytics
		App::import('Controller', 'HistoryCredits');
		global $HistoryCredit;
		$HistoryCredit = new HistoryCreditsController;
		$HistoryCredit->constructClasses();

		/* Landing Page Engine */
		App::import('Controller', 'LandingPageEngine');
		global $LandingPageEngine;
		$LandingPageEngine = new LandingPageEngineController;
		$LandingPageEngine->constructClasses();

		/* Widget Engine */
		App::import('Controller', 'WidgetEngine');
		global $WidgetEngine;
		$WidgetEngine = new WidgetEngineController;
		$WidgetEngine->constructClasses();
	}

	/* We don't use the engine queue processing in this class */
	function timer_start() {}
	function timer_stop() {}
	function batch_data($batch, $data) {}
	function save_item($identifier, $item) {}

	function index($domain_id = -1) {
		$this->autoRender = false;

		$count = 0;

        $oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
        $oTimer = new \CI\Engine\Timer();
		if ($domain_id >= 0) {
			$all_bits = $oHub->idToBit($domain_id);
			$all_bits = array($all_bits);
			$timer = $oTimer->idToSimilarTimer($domain_id);
		} else {
			$all_bits = $oHub->getAllActiveBits();
			$timer = TIMER_SIMILAR_ENGINE;
		}

		/* Timers & Limits */
		$this->Timer->start($timer);
		set_time_limit(TIME_LIMIT_SIMILAR_ENGINE);
		ini_set('memory_limit', MEMORY_LIMIT_SIMILAR_ENGINE.'M');

		$script_total = count($all_bits);
		$script_count = 0;
		$this->Timer->progress_set(0);
		$this->Timer->running_set();

		$total_limit = 800000;
		foreach ($all_bits as $domain_bit) {
			$time_start = microtime(true);
			$domain_id = $oHub->bitToId($domain_bit);

            $datas = $this->Log->get_last_logs($total_limit, $domain_bit);
			echo "datas: " . count($datas) . "\n";
			debug_memory("Memory usage after log");

			/* Process it */
			$neighbors = $this->process($datas, $domain_bit);
			unset($datas);
			echo "neighbors: " . count($neighbors) . "\n";
			debug_memory("Memory usage after process");

			/* Get good accounts */
			$accounts = $this->accounts_get($domain_bit);
			echo "accounts: " . count($accounts) . "\n";
			debug_memory("Memory usage after accounts");

			/* Find best matches */
			$matches = $this->matches($neighbors, $accounts, $domain_bit);
			echo "matches: " . count($matches) . "\n";
			debug_memory("Memory usage after matches");
            unset($neighbors);

			/* Save results off */
			$this->save_matches($matches, $domain_id, $accounts);

			/* Keep count of number of matches */
			$tmp_count = count($matches);
			$count += $tmp_count;

			unset($matches);

			$script_count++;
			$this->Timer->progress_set($script_count, $script_total);
			$this->Timer->running_set();
		}

		echo "Complete. Saved: ".$count." matches\n";

		/* Save off timer */
		$data = $this->Timer->set_memory_limit();
		$this->Timer->stop_save($data);
	}

	function account_skip($account, $website) {
		return 0;
	}

	function parse($entry) {
        return array(
            'ip' => $entry['logs']['ip'],
            'page_title' => $entry[0]['url']
        );
	}

    function process($entries, $domain_bit) {
		$neighbors[][] = array();
		$session_array = array();

		foreach ($entries as $entry) {
			$tuples = $this->parse($entry, $domain_bit);

			if ($tuples) {
				$ip = $tuples['ip'];
				$page_title1 = $tuples['page_title'];

				if (empty($session_array[$ip])) {
					$session_array[$ip] = array();
				}

				if (!in_array($page_title1, $session_array[$ip])) {
					// Increment counts
					foreach ($session_array[$ip] as $key => $value) {
						$page_title2 = $value;

						// Create one if it
						// doesn't exist
						if (empty($neighbors[$page_title1][$page_title2])) {
							$neighbors[$page_title1][$page_title2] = 0;
						}
						// Create one if it
						// doesn't exist
						if (empty($neighbors[$page_title2][$page_title1])) {
							$neighbors[$page_title2][$page_title1] = 0;
						}

						$neighbors[$page_title1][$page_title2]++;
						$neighbors[$page_title2][$page_title1]++;
					}

					// Add it to the session
					array_push($session_array[$ip], $page_title1);

				}
			}
		}

		return $neighbors;
	}

	function matches($neighbors, $white_list_accounts, $domain_bit) {
		$min_match = 5;
		$tmp = array();
		$out = array();

		// We only want the account ids
		$white_list_account_ids = array();
		foreach ($white_list_accounts as $account) {
			$white_list_account_ids[] = $account['Account']['id'];
		}

		// Find the links to retrieve them from the database in just one call.
		$arrLinks = array();
        foreach ($neighbors as $link => $neighbor) {
            // Make sure we have enough options to make a decision
            if (count($neighbor) < SIMILAR_NUM_LINKS) {
                continue;
            }
            $arrLinks[] = $link;
            foreach ($neighbor as $title) {
                $count = array_pop($neighbor);
                // If not enough connections for the last one we throw the whole
                // link away
                if ($count < $min_match) {
                    break;
                }
                $arrLinks[] = $title;
            }
        }
        $arrLinks = array_unique($arrLinks);
        if (empty($arrLinks)) {
            return array();
        }
        $joins = array(
            array(
                'table' => 'websites',
                'alias' => 'Website',
                'type' => 'INNER',
                'conditions' => array(
                    'Website.id = Page.website_id',
                )
            )
        );
        $pages = $this->Page->find(
            "all",
            array(
                "conditions" => array(
                    "Page.title_url" => $arrLinks,
                    "Page.status" => 0,
                    "Website.status" => 0
                ),
                "joins" => $joins,
                "fields" => array(
                    'Page.id',
                    'Page.website_id',
                    'Page.title_url',
                    'Page.status',
                    'Page.domain_bitfield',
                    'Page.category',
                    'Page.subcategory',
                    'Page.content_rating',
                    'Page.demographic_sex',
                    'Website.id',
                    'Website.account_id',
                    'Website.domain_primary',
                    'Website.domain_bitfield',
                    'Website.allowed_categories_bitfield',
                    'Website.strict_category',
                    'Website.category',
                    'Website.subcategory',
                    'Website.demographic_sex',
                    'Website.content_rating',
                    'Website.whitelist',
                    'Website.blacklist',
                )
            )
        );
        unset($arrLinks);
        // Transform array from indexed to associative
        $total_pages = (count($pages) - 1);
        for ($i = 0; $i <= $total_pages; $i++) {
            $page = $pages[$i];
            $pages[$page['Page']['title_url']] = $page;
            unset($pages[$i]);
        }
		foreach ($neighbors as $link => $neighbor) {
		    echo ".";
		    if (empty($pages[$link])) {
		        continue;
		    }
			// Sort these so most common are at the top
			asort($neighbor);
			$keys = array_keys($neighbor);
			$neighbor_count = count($neighbor);
			for ($i = 0, $j = 0; $i < $neighbor_count; $i++) {
				$tmp_neighbor = array_pop($keys);
				if (empty($pages[$tmp_neighbor])) {
				    continue;
				}

				$count = array_pop($neighbor);
				// If not enough connections for the last one we throw the whole link away
				if ($count < $min_match) {
					break;
				}

				$valid = $this->link_valid($pages[$link], $pages[$tmp_neighbor], $domain_bit, $white_list_account_ids);
				if (is_array($valid) && isset($valid['page_link_id'])) {
					// We want it!
					$tmp[$j] = $valid['neighbor_link_id']; //$tmp_neighbor;
					// Make sure we don't have too many
					if ($j++ >= SIMILAR_NUM_LINKS) {
						break;
					}
				}
			}
			if ($count >= $min_match) {
				$out[$pages[$link]['Page']['id']] =
			        array(
                        'page' => $pages[$link],
                        'similar' => $tmp
				    );
			}
		}
		echo "\n";
		return $out;
	}

	function link_valid($page_link, $neighbor_link, $domain_bit, $white_list_account_ids) {
		// Check page status
		if ($page_link['Page']['status'] != PAGE_STATUS_APPROVED) {
			return 0;
		}

		if ($neighbor_link['Page']['status'] != PAGE_STATUS_APPROVED) {
			return 0;
		}

		// Check to make sure both pages are in the same domain
		if (!($page_link['Page']['domain_bitfield'] & $domain_bit)) {
			return 0;
		}

		if (!($neighbor_link['Page']['domain_bitfield'] & $domain_bit)) {
			return 0;
		}

		// Category
		if (!$this->Rule->category(
            $page_link['Page']['category'], $neighbor_link['Page']['category']
        )) {
			return 0;
		}

		// Content
		if (!$this->Rule->content_rating(
            $page_link['Page']['content_rating'], $neighbor_link['Page']['content_rating']
        )) {
			return 0;
		}

		// Check the neighbor account and make sure we can send them traffic
        $account_id = $neighbor_link['Website']['account_id'];
		if (!in_array($account_id, $white_list_account_ids)) {
			return 0;
		}

		return array(
            'page_link_id' => $page_link['Page']['id'],
            'neighbor_link_id' => $neighbor_link
        );
	}

	function save_matches($matches, $domain_id, $accounts) {
		global $LandingPageEngine;
		global $WidgetEngine;

		foreach ($matches as $page_id => $links) {
			foreach ($links['similar'] as $similar_page) {
			    echo ".";
				// Landing Page
				$LandingPageEngine->landing_pages_add_similar($similar_page, $page_id);

				// Widget
				$WidgetEngine->widgets_add_similar($similar_page, $links['page']);
			}
		}
		$this->LandingPageAnalytic->flush_bulk();
		echo "\n";
	}

	function clear_cache($website_id = 0, $domain_bit = 0) {
		set_time_limit(10*60);

		$count = 0;

		if (!$website_id) {
			$websites = $this->Website->active();
		} else {
			$website = $this->Website->findById($website_id);
			$websites[0] = $website;
		}

		if (!$domain_bit) {
            $oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
			$domain_bits = $oHub->getAllBits();
		} else {
			$domain_bits[0] = $domain_bit;
		}

		foreach ($websites as $website) {
			$pages = $this->Page->find("all", array("conditions" =>
								array("website_id" => $website['Website']['id'],
								      "visible" => true)));
			foreach ($pages as $page) {
				foreach ($domain_bits as $bit) {
					$this->SimilarEngine->clear_similar_page($page['Page']['id'], $bit);
				}
			}
		}
	}

	function get_similar_page_count($website = null) {
		set_time_limit(30*60);

		$count = 0;

		if (!$website) {
			$websites = $this->Website->active();
			$website_id = 0;
		} else {
			$websites[0] = $website;
			$website_id = $website['Website']['id'];
		}

        $oHub = new \CI\Hub(new \CI\Hub\DataSource\MyArray());
		$all_bits = $oHub->getAllBits();
		foreach ($websites as $website) {
			$pages = $this->Page->find("all", array("conditions" =>
								array("website_id" => $website['Website']['id'],
								      "visible" => true)));

			foreach ($pages as $page) {
				foreach ($all_bits as $domain_bit) {
					$similar_pages = $this->SimilarEngine->get_similar_page($page['Page']['id'], $domain_bit);
					if ($similar_pages) {
						$count++;
					}
				}
			}
		}

		// Cache it
		$this->SimilarEngine->set_similar_page_count($website_id, $count);

		echo "Number similar pages: ".$count;

		return $count;
	}

};

