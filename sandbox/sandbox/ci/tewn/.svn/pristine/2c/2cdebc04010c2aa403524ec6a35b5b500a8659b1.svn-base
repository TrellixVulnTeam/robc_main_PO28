<?php
namespace Test\Error;
use CI\Error\Register as ErrorRegister;

/**
 * @group error
 * @group error_register
 */
class RegisterTest extends \PHPUnit_Framework_TestCase
{
    protected $_errorFixture;

    public function setup()
    {
        $backtrace = array(
            array(
                'file' => '/var/www/tewn/public_html/app/controllers/pages_controller.php',
                'line' => 890,
                'function' => 'plat_assert',
                'args' =>
                    array (
                      0 => 0,
                    ),
            )
        );

        $this->_errorFixture = array(
            'ip' => '127.0.0.1',
            'url' => 'www.url.com',
            'referer' => 'www.referer.com',
            'pid' => 123,
            'server' => 'Linux marcopatino 3.8.0-27-generic #40-Ubuntu SMP Tue Jul 9 00:17:05 UTC 2013 x86_64',
            'backtrace' => $backtrace
        );

        $this->_errorRegister = new ErrorRegister();
        $this->_errorRegister->setLimit(10); // To prevent unwanted flushs changing default limit in the class
    }

    public function test_errors_should_be_able_to_be_registered()
    {
        $expectedErrors = 1;

        $this->_errorRegister->registerError($this->_errorFixture);

        $this->assertEquals($expectedErrors, $this->_errorRegister->getErrorsCount());
    }

    public function test_error_register_on_flush_should_reset_errors()
    {
        $expectedErrors = 0;

        $this->_errorRegister->registerError($this->_errorFixture);
        $this->_errorRegister->flush();

        $this->assertEquals($expectedErrors, $this->_errorRegister->getErrorsCount());
    }

    public function test_flush_should_reset_all_errors()
    {
        $this->_errorRegister->registerError($this->_errorFixture);
        $this->_errorRegister->flush();

        $this->assertEmpty($this->_errorRegister->getErrors());
    }

    public function test_when_register_is_destructed_and_errors_are_left_should_flush_them()
    {
        $errorDeliverySpy = $this->getMockBuilder("CI\Error\Dealer\Mail")
            ->disableOriginalConstructor()
            ->getMock();

        $errorDeliverySpy->expects($this->once())->method('deal');

        $this->_errorRegister->addErrorDealer($errorDeliverySpy);
        $this->_errorRegister->registerError($this->_errorFixture);

        unset($this->_errorRegister); // This should trigger automatic flush
    }

    public function test_when_error_limit_is_reached_should_trigger_flush_and_report_to_the_dealer()
    {
        $errorDeliverySpy = $this->getMockBuilder("CI\Error\Dealer\Mail")
            ->disableOriginalConstructor()
            ->getMock();

        $errorDeliverySpy->expects($this->once())->method('deal');
        $expectedErrorsAfterAutoFlush = 0;

        $this->_errorRegister->setLimit(2);
        $this->_errorRegister->addErrorDealer($errorDeliverySpy);

        $this->_errorRegister->registerError($this->_errorFixture);
        $this->_errorRegister->registerError($this->_errorFixture);

        $this->assertEquals($expectedErrorsAfterAutoFlush, $this->_errorRegister->getErrorsCount());
    }

    public function test_error_with_same_backtrace_should_stack_as_error_ocurrences()
    {
        $aHash = array(
            array(
                '/var/www/tewn/public_html/app/controllers/pages_controller.php',
                890,
                'plat_assert'
            )
        );
        $expectedErrors = array(
            md5(serialize($aHash)) =>
                array_merge($this->_errorFixture, array('occurrences' => 2)
                )
        );

        $this->_errorRegister->registerError($this->_errorFixture);
        $this->_errorRegister->registerError($this->_errorFixture);

        $this->assertEquals($expectedErrors, $this->_errorRegister->getErrors());
    }

    public function test_errors_with_same_url_should_stack_as_error_ocurrences()
    {
        $newErrorWithDifferentUrl = $this->_errorFixture;
        $newErrorWithDifferentUrl['url'] = 'www.newurl.com';
        $expectedUrls = "{$this->_errorFixture['url']}, {$newErrorWithDifferentUrl['url']}";

        $this->_errorRegister->registerError($this->_errorFixture);
        $this->_errorRegister->registerError($newErrorWithDifferentUrl);

        $actualErrors = $this->_errorRegister->getErrors();
        $actualErrors = array_shift($actualErrors); // Get the first element

        $this->assertEquals($expectedUrls, $actualErrors['url']);
    }

    public function test_error_with_invalid_backtrace_should_still_register_error_and_stack_together()
    {
        $invalidBacktraceFixture = array(
            'ip' => '127.0.0.1',
            'url' => 'www.url1.com',
            'referer' => 'www.referer1.com',
            'pid' => 1234,
            'server' => 'Linux 3.8.0-27-generic #40-Ubuntu SMP Tue Jul 9 00:17:05 UTC 2013 x86_64',
            'backtrace' => null
        );
        $expectedErrors = 4;
        $expectedOccurrences = 3;

        $this->_errorRegister->registerError($invalidBacktraceFixture);
        $this->_errorRegister->registerError($invalidBacktraceFixture);
        $this->_errorRegister->registerError($invalidBacktraceFixture);
        $this->_errorRegister->registerError($this->_errorFixture);

        $result = $this->_errorRegister->getErrors();
        $result = array_shift($result); // Get the first error registered only //

        $this->assertEquals($expectedErrors, $this->_errorRegister->getErrorsCount());
        $this->assertEquals($expectedOccurrences, $result['occurrences']);
    }
}